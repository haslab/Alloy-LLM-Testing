[
    {
        "example": "Production line",
        "model": "sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {}",
        "id": "dyj49tEp7j6aWAQQX",
        "requirements": [
            {
                "description": "Workers are either human or robots",
                "pred": "this/inv1",
                "oracle": "{\n\t// Workers are either human or robots\n all w: Worker | w in Human or w in Robot\n}",
                "erroneous": [
                    "{\n\t// Workers are either human or robots\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in Human + Robot\n}",
                    "{\n\t// Workers are either human or robots\n all w: Worker | w in Human and w in Robot\n}",
                    "{\n\t// Workers are either human or robots\n  all w:Workstation | w.workers in Robot or w.workers in Human\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall e : Worker | e=Human or e=Robot \n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in Human + Robot and some w.workers\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Worker | w = Human + Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tWorker in Human or Worker in Robot\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Worker | w in Human\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Workstation | w.workers = Human + Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in (Human + Robot) and some w.workers and no Worker\n}",
                    "{\n\t// Workers are either human or robots\n\tWorkstation.workers = Human + Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall u: Worker | Human in u or Robot in u\n}",
                    "{\n\t// Workers are either human or robots\n  \tWorkstation.workers + Workstation.^succ.workers in Human or Workstation.workers + Workstation.^succ.workers in Robot\n  \t\n}",
                    "{\n\t// Workers are either human or robots\n\tWorker-(Human+Robot) & Workstation.workers = none\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Workstation | w.workers in Human implies w.workers not in Robot\n    all w : Workstation | w.workers in Robot implies w.workers not in Human\n\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation.^succ, w: ws.workers | w in Human or w in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Worker | w not in Human and w not in Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Worker | w in Human or w not in Robot \n    Human & Robot = none\n  \n}",
                    "{\n\t// Workers are either human or robots\n  all w : Workstation | Human in w.workers  or Robot in w.workers\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | Worker !in w.workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | (Human in Worker implies Human in w.workers) \n\tor (Robot in Worker implies Robot in w.workers) and lone w.workers and Worker in w.workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | (Human in Worker implies Human in w.workers) \n\tand (Robot in Worker implies Robot in w.workers) and lone w.workers and Worker in w.workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in (Human + Robot)\n  \tall h: Human | h in workers.h\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in (Human + Robot)\n  \tall H: Human | some w: Workstation | H in w.workers\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation, w: ws.workers | w in Human and w not in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation| (ws.workers in Human and ws.workers not in Robot) or (ws.workers not in Human and ws.workers in Robot)\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation.^succ | ws.workers in Human or ws.workers in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation.^succ, w: ws.workers | ws in Human or ws in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | w.workers + w.^succ.workers in Human or w.workers + w.^succ.workers in Robot\n  \t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Workstation.workers | w = Human or w = Human\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Workstation | w.workers = Human or w.workers = Human\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Workstation | w.workers = Human or w.workers = Robot\n}",
                    "{\n\t// Workers are either human or robots\n  not Worker in (Worker - Human - Robot)\n}",
                    "{\n\t// Workers are either human or robots\n\tHuman + Robot in Workstation.workers\n}",
                    "{\n\t// Workers are either human or robots\n  all h: Human, r: Robot | Workstation->h in workers or Workstation->r in workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Worker | w in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall disj w,a : Worker | (w = Human implies a = Human) or (a = Robot implies w \t\t= Robot)\n}",
                    "{\n\t// Workers are either human or robots\n\tall disj w,a : Worker | w.(~workers) =a.(~workers)implies((w = Human implies \t  a = Human) or (a = Robot implies w = Robot))\n}",
                    "{\n\t// Workers are either human or robots\n\tsome w : Worker | w = Human or w = Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Worker | w in Human or w = Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall wo: Workstation | (Human in wo.workers implies Robot not in wo.workers) and \t\t\t\t\t\t  (Robot in wo.workers implies Human not in wo.workers)\n}",
                    "{\n\t// Workers are either human or robots\n\tsome Human+Robot & Workstation.workers \n}",
                    "{\n\t// Workers are either human or robots\n  all w : Worker | w =  Human - Robot\n\t\n}"
                ],
                "instances": "run Pos1 {\n    some disj WS1 : Workstation {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        no workers\n        no succ\n\n        no Worker\n        no Human\n        no Robot\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Positive: there are no workers, so vacuously every worker is human or robot.\n    }\n} for 1 Workstation, 0 Worker, 0 Product expect 1\n\nrun Pos2 {\n    some disj WS1 : Workstation | some disj W1 : Worker {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        no succ\n\n        Worker = W1\n        Human = W1\n        no Robot\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Positive: the only worker W1 is a Human, so all workers are either human or robot.\n    }\n} for 1 Workstation, 1 Worker, 0 Product expect 1\n\nrun Pos3 {\n    some disj WS1 : Workstation | some disj W1, W2 : Worker | some disj P1 : Product {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1 + WS1->W2\n        succ = WS1->WS1\n\n        Worker = W1 + W2\n        Human = W1\n        Robot = W2\n\n        Product = P1\n        no Material\n        Component = P1\n        Dangerous = P1\n        no parts\n        workstation = P1->WS1\n\n        // Positive: every worker is either Human (W1) or Robot (W2); none are outside Human+Robot.\n    }\n} for 1 Workstation, 2 Worker, 1 Product expect 1\n\nrun Neg1 {\n    some disj WS1 : Workstation | some disj W1 : Worker {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        no workers\n        no succ\n\n        Worker = W1\n        no Human\n        no Robot\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: worker W1 is neither Human nor Robot.\n    }\n} for 1 Workstation, 1 Worker, 0 Product expect 0\n\nrun Neg2 {\n    some disj WS1 : Workstation | some disj W1, W2 : Worker {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1 + WS1->W2\n        succ = WS1->WS1\n\n        Worker = W1 + W2\n        Human = W1\n        no Robot\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: W2 is a Worker but is neither Human nor Robot.\n    }\n} for 1 Workstation, 2 Worker, 0 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2, W3 : Worker | some disj P1 : Product {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2 + WS2->W3\n        succ = WS1->WS2\n\n        Worker = W1 + W2 + W3\n        Human = W1\n        Robot = W2\n\n        Product = P1\n        Material = P1\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: W3 is a Worker but is neither Human nor Robot.\n    }\n} for 2 Workstation, 3 Worker, 1 Product expect 0",
                "input tokens": 1959,
                "output tokens": 6706
            },
            {
                "description": "Every workstation has workers and every worker works in one workstation",
                "pred": "this/inv2",
                "oracle": "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws: Workstation | some ws.workers\n  \tall w: Worker | one ws: Workstation | w in ws.workers\n}",
                "erroneous": [
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all wst : Workstation | some wst.workers and one workers.wst \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t(all w : Workstation | some w.workers) and (all w1 : Worker | w1 in Workstation.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall k: Workstation | some k.workers\n  \t//all w: Worker | all disj k1: Workstation, k2: Workstation | (w in k1.workers) implies (w not in k2.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker, k: Workstation | w in k.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all wst : Workstation , w : Worker| some wst.workers and one workers.wst \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wo: Workstation, wor: Worker | some wo.workers and one workers.wor\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall k: Workstation | some k.workers\n  \tall w: Worker, k: Workstation | w in k.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | some(w.workers)\n  \tall w : Worker | lone(workers.w)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall u: Worker | one w: Workstation | u in w.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n  \tall w : Worker | w in Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Workstation | one w.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers and (all w: Worker | one s: Workstation | w in s.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Worker | lone wo: Workstation | w in Workstation.workers and w in wo.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker, k: Workstation | some k.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall ws: Workstation | ws.workers in Workstation and all w: ws.workers | w in ws\n\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | some w1 : Worker | w1 in w.workers\n  \tone w : Workstation | all w1 : Worker | w1 in w.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation |\n\t\tone ws.workers and\n\t\tall w : Worker | w in Worker and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall s : Workstation, w: Worker | some s.workers and some workers.w \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall s: Workstation | all w: Worker | w in s.workers\n  \tall w: Worker | one s: Workstation | w in s.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y: Worker |y in x.workers\n  \n\t//all y: Worker |  one x: Workstation | x in workers.y implies\n\t//all x: Workstation | one y: Worker | x in workers.y\n\tone x: Workstation, y: Worker | some x implies y in x.workers\n  \t\t\t\t\t\t\t\t\t\t\n\n  \t\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tsome w1: Worker | Workstation.workers = w1\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w : Worker, ws : Workstation | ws in workers.w and lone ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t//all x: Workstation| one y: Worker | x in workers.y implies some x.workers and one workers.y\n\tall x: Workstation| some x.workers\n  //one x: Workstation| all y: Worker | x in workers.y\n  one x: Workstation| some y: Worker | y in x.workers implies one y\n  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation | some ws.workers\n\tone Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n  \tone workers.Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker |  w in Workstation.workers\n  \tsome w: Worker | lone ws: Workstation | ws.workers = w\n  }",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | #(w.workers) > 1\n  \n    all w: Worker | one work : Workstation | w in work.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t(all w: Workstation | some w.workers)\n\t&& (all w: Worker | one (Workstation->workers).w)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | one x.workers iff one workers.x  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome workers and one ~workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers implies x in workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall x : Workstation | some Worker \n    all x : Worker | one Workstation\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers in (Workstation one -> one Worker)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation | some wks : ws.workers | no (wks & (Workstation - ws).workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all wo : Workstation | (lone w : Worker | wo-> w in workers )\n\n  all w : Worker | (one wo : Workstation | wo -> w in workers)\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t//all y: Worker |  one x: Workstation | x in workers.y implies\n\t//all x: Workstation | one y: Worker | x in workers.y\n\tone x: Workstation, y: Worker | some x implies y in x.workers\n//\tall x: Workstation, y: Worker | some x implies some y\n\t//all x: Workstation, y: Worker | some y implies one x\n  \n  \tall y: Worker | one x: Workstation | some y implies y in x.workers\n  \n\n  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all w : Workstation | some w.workers\n  all w : Worker | one s : Workstation | w in s.workers implies w not in (Workstation-s).workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w: Workstation | #(w.workers) > 0 and #(w.workers & Human)  > 0 \n  \tall disj w1,w2: Workstation |  #(w1.workers & w2.workers) = 0\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Workstation, u: Worker | (u in w.workers) implies (u in Human or u in Robot)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone ws : Workstation | all w : Worker | one ws1 : Workstation | some w1 : Worker | w1 in ws1 and w in ws\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Workstation | some w.workers\n  \tall w: Workstation, u: Worker | (u in w.workers) implies (u in Human or u in Robot)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  workers in Workstation some -> one Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all ws : Workstation, w : Worker |  one (ws.workers)  and some workers.w \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation, u: Worker | some w.workers or one workers.u\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation, w: Worker | (ws in ws.succ) implies (w in ws.workers)\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation | #ws.workers>0 and no ws1: Workstation | ws1 != ws and #(ws.workers & ws1.workers) =0\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers and lone workers.y  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers implies one workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers in (Workstation lone -> one Worker )\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers in (Workstation some -> lone Worker)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall k: Workstation | some k.workers\n  \tsome w: Worker, k1: Workstation, k2: Workstation | (w not in k1.workers) and (w not in k2.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wo: Workstation, wor: Worker | some workstation.workers and one workers.wor\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wo: Workstation, wor: Worker | one wo.workers and one workers.wor\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all w:Workstation | some ws:Worker | ws in w.workers \n  all ws:Worker | one w:Workstation | w.workers in ws\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall s : Workstation, w : Worker | some Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n  \tall w : Human | w in Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w : Worker, ws : Workstation | ws in workers.w and some ws.workers and some ws.succ.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w : Worker, ws : Workstation | ws in workers.w and ws.workers in w and some ws.succ.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall x : Workstation | some Worker \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\n  all w : Worker, s : Workstation | some s.workers and one workers.w\n  all s : Workstation | s.succ in Workstation-s\n  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation |\n\t\tone ws.workers and\n\t\tall w : Worker | w in Worker-Robot and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Worker | w in Human or w in Robot\t\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall wk : Workstation | all w : Worker | some wk.workers and (w in wk.workers <=> w not in wk.workers.^(succ)) and (wk not in wk.succ)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation | x.workers != none\n  \tall x: Worker | some y: Workstation | x in y.workers implies\n  \t\t\t\t\t\t\t\t\tx not in (Workstation - y).workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws: Workstation | ws.workers in Worker\n\tall w: Worker | one Workstation.workers\n\tall sw: Workstation.succ | sw.workers in Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone ws : Workstation | all w : Worker | one ws1 : Workstation | some w1 : Worker | w1 in ws1.workers and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone ws : Workstation | all w : Worker | all ws1 : Workstation | some w1 : Worker | w1 in ws1.workers and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tone ws : Workstation | all w : Worker | w in ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wt : Workstation | some w : Worker | w in wt.workers\n  \tsome wt : Workstation | all w : Worker | w in wt.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t// all w: Worker |  w in Workstation.workers\n  \tsome w: Worker | lone ws: Workstation | ws.workers = w\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker | some w2: Worker |  w in Workstation.workers and Workstation.workers = w2\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker | some w2: Worker | lone w3: Workstation |  w in Workstation.workers and w3.workers = w2\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w: Workstation | #(w.workers) > 0 and #(w.workers & Human) > 0 \n  \tall disj w1,w2: Workstation |  #(w1.workers & w2.workers) = 0\n  \tno w: Worker | some ws: Workstation | w not in ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w: Workstation | #(w.workers) > 0 and #(w.workers & Human) > 0 \n  \tall disj w1,w2: Workstation |  #(w1.workers & w2.workers) = 0\n  \tno w: Worker | lone ws: Workstation | w not in ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | one w2 : Workstation | all ws : Worker | some w.workers and w2.workers = ws\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Worker | lone x:Workstation| w in Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all ws : Workstation, w : Worker | one (ws.workers)\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all ws : Workstation, w : Worker |  some (ws.workers)  and one workers.w and some ws.succ\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws: Workstation, w: Worker | one ws1: Workstation | (ws -> w in workers) implies w in ws1 \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | #(w.workers) > 1\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation, w: Worker | (ws in ws.succ) implies (w in ws.workers) \n  all w: Worker | one ws: Workstation | w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation, w: Worker | (ws in ws.succ) implies (w in ws.workers) \n  all w: Worker | some ws: Workstation | w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tWorkstation.workers != none implies Workstation.workers = Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers.Worker = Workstation and #workers = #Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone x: Workstation| one y: Worker | y in x.workers and x in workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | one x.workers iff one workers.y  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers iff one workers.y  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation| one y: Worker | some x.workers and one workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation| one y: Worker | x in x.workers implies some x.workers and one workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation| one y: Worker | x in workers.y implies some x.workers and one workers.y\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1 : Workstation {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        no workers\n        no succ\n\n        no Worker\n        no Human\n        no Robot\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: WS1 has no workers, violating \"every workstation has workers\"; no workers ensures the Human/Robot condition holds vacuously.\n    }\n} for 1 Workstation, 0 Worker, 0 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2 : Workstation | some disj W1 : Worker {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W1\n        succ = WS1->WS2\n\n        Worker = W1\n        Human = W1\n        no Robot\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: W1 works in two workstations (WS1 and WS2), violating \"every worker works in one workstation\". Both WS1 and WS2 have workers, so only the second clause is violated.\n    }\n} for 2 Workstation, 1 Worker, 0 Product expect 0\n\nrun Neg3 {\n    some disj WS1 : Workstation | some disj W1, W2 : Worker {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        succ = WS1->WS1\n\n        Worker = W1 + W2\n        Human = W1\n        Robot = W2\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: W2 is a worker but is not assigned to any workstation, violating \"every worker works in one workstation\". All workers are Human or Robot.\n    }\n} for 1 Workstation, 2 Worker, 0 Product expect 0",
                "input tokens": 3727,
                "output tokens": 5587
            },
            {
                "description": "Every component is assembled in one workstation",
                "pred": "this/inv3",
                "oracle": "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one c.workstation\n}",
                "erroneous": [
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one w: Workstation | c in w.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | some c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n    all c : Component | one Workstation \n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | lone c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone Component.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n    workstation in Component one -> Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c:Component | c.workstation = Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n    workstation in Component lone -> Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | one w : Workstation | c.workstation in w\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone x: Workstation|all c:Component | c in workstation.x\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone w: Workstation | all c: Component | c in c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone c : Component | one w : Workstation | w in c\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c: Component | #c.workstation = 2\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n    workstation in Component some -> Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n  \tall c : Component, p : Product | p.parts in c.workstation\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall p:Product | p in Component and one(p.workstation)\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | c.workstation not in (Component-c).workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c : Component | all w1, w2 : Workstation | w1 in c.workstation implies w2 not in c.workstation and w1 != w2\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tworkstation in Component one -> one Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n  lone Component.workstation\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall p: Product | all c: p.parts | c.workstation = p.parts.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone c : Component | one w : Workstation | w in c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | one w : Workstation | c.parts in w.succ\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c : Component, w : Workstation | c.workstation in w\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c : Component | c.workstation in Workstation.succ\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one Component.workstation\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1 : Workstation | some disj W1 : Worker | some disj C1 : Component {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        no succ\n\n        Worker = W1\n        Human = W1\n        no Robot\n\n        Product = C1\n        no Material\n        Component = C1\n        no Dangerous\n        no parts\n        no workstation\n\n        // Negative: Component C1 is assembled in no workstation (workstation is empty), violating \"every component is assembled in one workstation\".\n        // Other requirements satisfied: WS1 has worker W1 and W1 works in exactly one workstation; W1 is a Human.\n    }\n} for 1 Workstation, 1 Worker, 1 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2 : Worker | some disj C1 : Component {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2\n        succ = WS1->WS2\n\n        Worker = W1 + W2\n        Human = W1\n        Robot = W2\n\n        Product = C1\n        no Material\n        Component = C1\n        no Dangerous\n        no parts\n        workstation = C1->WS1 + C1->WS2\n\n        // Negative: Component C1 is assembled in two workstations (WS1 and WS2), violating \"every component is assembled in one workstation\".\n        // Other requirements satisfied: each workstation has a worker and each worker works in exactly one workstation; workers are either Human (W1) or Robot (W2).\n    }\n} for 2 Workstation, 2 Worker, 1 Product expect 0\n\nrun Neg3 {\n    some disj WS1 : Workstation | some disj W1 : Worker | some disj C1, C2 : Component {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        no succ\n\n        Worker = W1\n        Human = W1\n        no Robot\n\n        Product = C1 + C2\n        no Material\n        Component = C1 + C2\n        no Dangerous\n        no parts\n        workstation = C1->WS1\n\n        // Negative: C1 is assembled in exactly one workstation (WS1) but C2 is assembled in none, so not every component has exactly one workstation.\n        // Other requirements satisfied: WS1 has worker W1, and W1 works in exactly one workstation; W1 is a Human.\n    }\n} for 1 Workstation, 1 Worker, 2 Product expect 0",
                "input tokens": 2907,
                "output tokens": 5605
            },
            {
                "description": "Components must have parts and materials have no parts",
                "pred": "this/inv4",
                "oracle": "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some c.parts\n    all m: Material | no m.parts\n}",
                "erroneous": [
                    "{\n  // Components must have parts and materials have no parts\n  all c: Component, m: Material | some c.parts and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some c.parts and all m: Material | no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | some p.parts implies p in Component \n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall o: Component | some o.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t(some Component.parts) and (no Material.parts)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Material | p.parts not in Product\n  \tall p: Component | p.parts in Product\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p : Product | p in Component and some p.parts\n  \tall m : Product | m in Material and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall m:Material |\n  \t\tm.parts not in Product.parts\n  \n  \tall c:Component |\n  \t\tsome p:Product.parts |\n  \t\t\tp in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: Component | c.parts in Product and no m: Material | m.parts in Product\n\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n\t// all components must have parts (itself included)\n  \t// all materials must have no parts (itself included)\n  \tall c: Component | c.parts in (Product - c)\n  \tall m:Material | m.parts not in (Product)\n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component, m:Material | some p:Product | p in c.parts and p not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | c.parts != none and all m: Material | m not in Product.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | p.parts in (Component-Material)\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \t//all p:Product | p not in p.^parts\n  \tall c: Component | c.*parts in (Product - c)\n  \t//all m: Material  | m.parts not in (Product)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c : Component | some parts.c\n  \n  all m : Material | no parts.m\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | #(c.parts) >= 0  and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c: Component, m: Material | #c.parts>0 and #m.parts =0 and c not in c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c:Component | some p: Product | p in c.parts\n  \tall c:Material | some p: Product | p not in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p : Product, m : Material, c : Component | p in c.parts and p not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tno (iden & parts) and parts in (Component -> some Product)\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t//all c: Component | some c.parts\n  \t //all m: Material | no m.parts\n  \n  \tall c: Component, p: Product | p in c.parts\n  \t all m: Material, p: Product | not p in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component, p: Product | c in p.parts\n  \t all m: Material, p: Product | not m in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t//all c: Component | some c.parts\n  \t //all m: Material | no m.parts\n  \n  \tall c: Component, p: Product | c in p implies c in p.parts\n  \t all m: Material, p: Product | m in p implies m not in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tsome (Product & Component - Dangerous).parts and no (Product & Material - Dangerous).parts \n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | some p : Product | p in parts.c and p not in parts.m\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component, m: Material | c in parts.c and m not in parts.m\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n\tall c : Component, m : Material, p : Product | one p2 : Product | c not in c.parts and c not in parts.c and p not in m.parts and p2 in c.parts\n}",
                    "{\n  all p : Product | (p not in p.parts and p not in parts.p) and #(p.parts)>0 implies p in Component \n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tparts in (Component -> set Product -iden)\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c: Component |\n\t\tsome c.parts and\n\t\tno c.parts\n\n\tall m: Material |\n\t\tno m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | all m : Material | one c.parts and no m.parts\t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t//all m : Material | all c : Component | none m.parts | some c.parts\n    Product not in Material.parts\n  \tProduct in Component.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product| (p = Component implies p.parts != none and p not in p.parts) and\n  \t(p = Material implies p.parts = none)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | lone c.parts and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | all m : Material | some c.parts - c and no m.parts\t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  no parts.Material\n  some parts.Component\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  no parts.Material\n  all c:Component | some c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | p.parts in Component and p.parts not in Material\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some parts\n  \tall m: Material | not some parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, x: Workstation, p:Product | c in workstation.x implies (c in parts.p and Material not in parts.p)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | p in Material implies not one p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tno p:Product | p.parts in Material\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c : Component | some(c.parts)\n\tsome(Component <: parts) and no (Material <: parts)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | c.parts != none\n  \tall c : Material | c.parts != none\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: (Material + Component) | (c in Material) implies some c.parts else no c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | some p : Product | c in parts.p and m in parts.p \n}",
                    "{\n  all c : Component | one p : Product | all m : Material | p in c.parts and p not in m.parts\n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n  all c : Component | one p : Product | all m : Material | p in c.parts and p not in m.parts and c not in c.parts and m not in m.parts\n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n\t//all p : Product | #(p.parts)>0 implies p in Component else p in Material\n  \n  \tall c : Component | some Component.parts\n  \tall m : Material | no Material.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c : Product | some p: c.parts | p in Product implies c in Component\n  \tall prod:Product | one p:prod.parts | p not in Product implies prod in Material\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | some c.parts\n    all m : Material | no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component| one wt :Workstation | wt in c.workstation\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: Component | c.parts in (Product - c)\n  \tall m:Material | m.parts not in (Product - m)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: Component | c.^parts in (Product - c)\n  \tall m: Material  | m.parts not in (Product)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \tall p:Product | p not in p.^parts\n  \t//all c: Component | c.^parts in (Product - c)\n  \t//all m: Material  | m.parts not in (Product)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \t//all p:Product | p not in p.^parts\n  \tall c: Component | c.^parts in (Product - c)\n  \t//all m: Material  | m.parts not in (Product)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \tall p:Product | p.parts in (Product-p)\n  \t//all c: Component | c.*parts in (Product - c)\n  \t//all m: Material  | m.parts not in (Product)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \t#(Component & Product.parts) != 0\n  \t#(Material & Product.parts) != 0\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | all m : Material | some c.parts - c and no m.parts - m\t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c : Component, p : Product | p.parts in c\n  \tall m : Material, p : Product | m not in p.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | some p:Product | p in p.parts and p not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | some p:Product | p in p.parts and p not in m.parts\n  \tall c:Component | some p: Product | c.parts = p\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | some p:Product | p in p.parts and p not in m.parts\n  \tall c:Component | some p: Product | p in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some c.parts\n  \tall m: Material | one m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product, c: Component, m: Material |\n  \t\tsome c.parts implies no m.parts\n  \t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n  all c : Component | c-> c in parts\n  all m : Material | no m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n  all c : Component | (some c1 : Component | c-> c1 in parts)\n  all m : Material | no m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n  all c : Component | (some c : Component | c-> c in parts)\n  all m : Material | no m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product | some p2: Product | p != p2 and (p in Component implies p2 in p.parts) or (p in Material implies p2 not in p.parts)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product | some p2: Product | p in Material implies p2 not in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall disj p, p2 : Product | p in Material implies p2 not in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product| (p = Component implies p.parts != none) and\n  \t(p = Material implies p.parts = none)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c : Component, m : Material | some c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | all m: Material | c in c.parts and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  some Component.parts and no Material.parts and all c:Component| c not in c.parts \n\n}",
                    "{\n\t// Components must have parts\n  all c: Component | lone(c.parts)\n  // and materials have no parts\n  all m: Material | no m.parts \n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | c.parts != none and m.parts = none\n  \tall c:Component | c not in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Material |\n  \t\tp.parts = none \n  \n  \tall p: Component |\n  \t\tsome (p.parts - p)\n  \n  \tProduct = Material + Component\n  \t\t\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1 : Workstation | some disj W1 : Worker | some disj C1 : Component {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        no succ\n\n        Worker = W1\n        Human = W1\n        no Robot\n\n        Product = C1\n        no Material\n        Component = C1\n        no Dangerous\n\n        no parts\n        workstation = C1->WS1\n\n        // Negative: Component C1 has no parts, violating \"components must have parts\".\n        // Other requirements satisfied: WS1 has worker W1; W1 is Human and works in exactly one workstation; C1 is assembled in exactly one workstation (WS1); there are no materials.\n    }\n} for 1 Workstation, 1 Worker, 1 Product expect 0\n\nrun Neg2 {\n    some disj WS1 : Workstation | some disj W1 : Worker | some disj M1 : Material {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        no succ\n\n        Worker = W1\n        no Human\n        Robot = W1\n\n        Product = M1\n        Material = M1\n        no Component\n        no Dangerous\n\n        parts = M1->M1\n        no workstation\n\n        // Negative: Material M1 has a part (itself), violating \"materials have no parts\".\n        // Other requirements satisfied: WS1 has worker W1; W1 is a Robot and works in exactly one workstation; there are no components, so each component being assembled in one workstation holds vacuously.\n    }\n} for 1 Workstation, 1 Worker, 1 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2\n        succ = WS1->WS2\n\n        Worker = W1 + W2\n        Human = W1\n        Robot = W2\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        no Dangerous\n\n        parts = C1->M1\n        workstation = C1->WS1 + C2->WS2\n\n        // Negative: Component C2 has no parts, violating \"components must have parts\".\n        // Other requirements satisfied: each workstation has one worker; each worker works in exactly one workstation; workers are either Human or Robot; each component is assembled in exactly one workstation (C1 in WS1, C2 in WS2); material M1 has no parts here.\n    }\n} for 2 Workstation, 2 Worker, 3 Product expect 0",
                "input tokens": 3209,
                "output tokens": 6861
            },
            {
                "description": "Humans and robots cannot work together",
                "pred": "this/inv5",
                "oracle": "{\n\t// Humans and robots cannot work together\n\tall w: Workstation, h: Human, r: Robot | (h in w.workers) implies (r not in w.workers)\n    //all w: Workstation | (Robot in w.workers) => !(Human in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                "erroneous": [
                    "{\n\t// Humans and robots cannot work together\n  \tall w:Workstation | no (w.workers & Human & Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) implies (Robot not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n    all w: Workstation, workers: w.workers | workers in Human or workers in Robot \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | some w : Worker | w in ws.workers and w in Human implies not w in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno disj w1, w2: Worker | w1 in Human and w2 in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | w.workers in Human implies w.workers not in Robot \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human & Robot) not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall y1,y2: Worker, x: Workstation | (y1 in x.workers) and(y1 in Human) implies (y2 not in x.workers) and (y2 not in Robot)  \n\n  //all r:Robot, h:Human, w:Workstation | w -> r in workers implies w->h not in workers\n\n  all r: Robot, h:Human, x:Workstation | x in workers.r implies x not in workers.h\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h:Human, r:Robot |some workers.h implies no workers.r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | no w.workers & (Human + Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) <=> (Robot not in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  //all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation | w.workers = Human or w.workers = Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t//if a workstation has 1 human, then it is all humans\n  \t//if a workstation has 1 robot, then it is all robots\n\tall ws: Workstation | one h: Human| (h in ws.workers) implies ws.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together \n  \tall ws: Workstation + Workstation.succ | one p:ws.workers | p in Human implies ws.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tWorkstation.workers in Human or Workstation.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws: Workstation | ws.workers not in (Human + Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | some w: Worker | w in ws.workers => (w in Robot iff not w in Human)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall wo : Workstation | all w : Worker, r : Robot | (wo in workers.w implies wo not in workers.r)\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall wo : Workstation | all w : Worker | w in wo.workers implies (w in Human and w !in Robot) and (w in Robot and w !in Human)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | one x : Worker| (x in w.workers and x in Human) implies w.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tone w: Workstation | all h: Human, r: Robot | h&r not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | Human in w.workers or Robot in w.workers\n\t//all w: Workstation | (Human in w.workers) => !(Robot in w.workers)\n    //all w: Workstation | (Robot in w.workers) => !(Human in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj w1, w2: Worker | (w1 in Human and w2 in Robot) implies no workers.w1&workers.w1\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | some h: Human | all r: Robot |not ( h in w.workers and r in w.workers )\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | all wrk: w.workers | wrk in Human\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w : Worker | (w in Human) iff (w not in Robot) \n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | (w.workers = Worker - Human) or (w.workers = Worker - Robot)\n\t//all w: Workstation | (Human in w.workers) implies (Robot not in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | !((Human in w.workers) or (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human | all r: Robot |one w:Workstation|  h in w.workers implies r not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall x: Workstation | x.workers in Human implies x.^succ.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | Human in w.workers => no Robot & w.workers else w.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t//if a workstation has 1 human, then it is all humans\n  \t//if a workstation has 1 robot, then it is all robots\n\tall ws: Workstation | some p: Worker | (p in ws.workers and p in Human) or (p in ws.workers and p in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tHuman in Workstation => Robot not in Workstation\n  \tRobot in Workstation => Human not in Workstation\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w: Workstation | some w.workers & Robot => no w.workers & Human and no w.succ.workers & Human\n  all w: Workstation | some w.workers & Human => no w.workers & Robot and no w.succ.workers & Robot\n  \n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w : Workstation |  some (w.workers&Robot) implies no(w.workers&Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj h: Human, r: Robot | Workstation.workers = h + r\n}",
                    "{\n\t// Humans and robots cannot work together\n\t//all h: Human, r: Robot, w: Workstation | {\n    //  h in w.workers => r not in w.workers\n    //  r in w.workers => h not in w.workers\n    //}\n  \tall h: Human, r: Robot, w: Workstation | w.workers != h & r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Worker | all s: Workstation | w in Human implies (s.workers in Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers | Human in w implies not Robot in w\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | all w1, w2: Worker | w1 in ws.workers and w2 in ws.workers \timplies ((w1 = Robot and w2 = Robot) or (w1 = Human and w2 = Human))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | ws.workers not in Human and ws.workers not in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | all w: Worker | w in ws.workers and (w in Robot iff not w in Human)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | all  w1: Worker, w2 : Worker | w1 in ws.workers and w2 in ws.workers and (w1 in Robot and w2 in Robot ) or (w1 in Human and w2 in Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | \n  \t\t(all w: ws.workers | w in Robot)\n\t\tor\n\t\t(all w: ws.workers | w in Robot)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | Human in w.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human not in w.workers) <=> (Robot not in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) => (Robot in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) => !(Robot in w.workers)\n    all w: Workstation | (Robot in w.workers) => !(Robot in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome w: Workstation | (w.workers = Worker - Human) or (w.workers = Worker - Robot)\n  \t//all w: Workstation | Human in w.workers or Robot in w.workers\n\t//all w: Workstation | (Human in w.workers) => !(Robot in w.workers)\n    //all w: Workstation | (Robot in w.workers) => !(Human in w.workers)\n  \t//all w: Workstation | (Robot in w.workers) implies (Human not in w.workers)\n  \t//all w: Workstation | !((Human in w.workers) and (Robot in w.workers))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some r: Robot | r in w.workers implies all wor: Worker | wor in w.workers and wor in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some r: Robot | r in w.workers implies all human: Human | human not in w.workers\n  \tall w : Workstation | some r: Human | r in w.workers implies all robot: Robot | robot not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation| (some w:Human | w in ws.workers implies workers.w not in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | (some w:Worker | w in Human and w in ws.workers implies all w1:Worker | w1 in Robot and w1 not in ws.workers) \n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w:Human | (some ws : Workstation | w in ws.workers implies Robot not in ws.workers)  \n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human, r: Robot | no workers.(h + r)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human, r: Robot | Workstation.workers not in (h + r)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome Workstation.*(succ.workers) & Human iff\n  \t\tno Workstation.*(succ.workers) & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome begin.*(succ.workers) & Human iff\n  \t\tno begin.*(succ.workers) & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall  ws:Workstation | some h:Human| (h in ws.workers) implies ws.workers in Human\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall  ws:Workstation | some h:Human| (h in ws.workers) implies ws.workers in Human\n    all  ws:Workstation | some r:Robot| (r in ws.workers) implies ws.workers in Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | Human in w.workers => Robot not in w.workers else w.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tsome p1,p2: Worker | all w : Workstation | (p1 in w.workers) and (p2 in w.workers) iff (p1 in Human and p2 in Robot) or (p1 in Robot and p2 in Human)  \n}",
                    "{\n\t// Humans and robots cannot work together\n\tno h: Human, r: Robot | some w: Workstation | w.workers = h + r\n}",
                    "{\n\t// Humans and robots cannot work together\n\t\n    // all ws : Workstation | ws.workers in Human or ws.workers in Robot\n  \n\n\tWorkstation.workers = Human + Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\t// all ws:Workstation | some w:Worker | \n  \tall ws:Workstation | some ws.workers & Worker iff no ws.workers & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w1:Human ,w2:Robot | some ws:Workstation | w1 in ws.workers implies w2 not in ws.workers\n  \n  \t// all ws:Workstation | some ws.workers & Human iff no ws.workers & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | Human in ws.workers implies no (Robot & ws.workers)\n  \tall ws : Workstation | Robot in ws.workers implies no (Human & ws.workers)\n  \n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Worker | all wk: Workstation | some wk.workers + Human + Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall disj u1, u2 : Worker, w : Workstation | u1 in w.workers implies u2 not in w.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t//if a workstation has 1 human, then it is all humans\n  \t//if a workstation has 1 robot, then it is all robots\n\tall ws: Workstation | one h: Human| one r:Robot| (h in ws.workers) implies ws.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t//if a workstation has 1 human, then it is all humans\n  \t//if a workstation has 1 robot, then it is all robots\n\tall ws: Workstation | one h: Human| (h in ws.workers) implies ws.workers in Human\n  \tall ws: Workstation | one r: Robot| (r in ws.workers) implies ws.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t//if a workstation has 1 human, then it is all humans\n  \t//if a workstation has 1 robot, then it is all robots\n\t//all ws: Workstation | one h: Human| (h in ws.workers) implies ws.workers in Human\n  \tall ws: Workstation | one r: Robot| (r in ws.workers) implies ws.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t//if a workstation has 1 human, then it is all humans\n  \t//if a workstation has 1 robot, then it is all robots\n\tall ws: Workstation | one p: Worker | (( p in ws.workers and p in Human) implies ws.workers in Human ) and ((p in ws.workers and p in Robot) implies ws.workers in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tHuman in Workstation.workers => Robot not in Workstation.workers\n  \tRobot in Workstation.workers => Human not in Workstation.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  no disj h1, h2: Human | h1.workstation = h2.workstation\n\tno disj r1, r2: Robot | r1.workstation = r2.workstation\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation |\n\t\tall wr: ws.workers |\n\t\t\t(wr in Robot => no ws.succ.workers & Human) and\n\t\t\t(wr in Human => no ws.succ.workers & Robot)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno disj h1, h2: Human | workers.h1 & workers.h2 != none\n    no disj r1, r2: Robot | workers.r1 & workers.r2 != none\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w: Human | w.workers in Robot and no w: Robot | w.workers in Human\n\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w: Human | w.workers in Robot and no w: Robot | workers.w in Human\n\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj w1, w2: Worker | (w1 in Human and w2 in Robot) or (w1 in Robot and w2 in Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w : Workstation |  no (w.workers & Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human | all r: Robot | one workers.h implies no workers.r\n  \tall h: Human | all r: Robot | one workers.r implies no workers.h\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj h: Human, r: Robot | Workstation.workers in h + r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj h: Human, r: Robot | Workstation.workers = h or Workstation.workers = r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno h: Human, r: Robot | one w: Workstation | h & r in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \n\tall h : Human , r : Robot | some (workers.h & workers.r)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w: Workstation | workers in w -> Human or workers in w -> Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Worker | w in Human \n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers, r : Robot | some h : Human | h in w implies not r in w\n    all w : Workstation.workers, r : Human | some h : Robot | r in w implies not h in w\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers | Human in w\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers | Human in w implies no w - Human\n    all w : Workstation.workers | Robot in w implies no w - Robot\n}",
                    "{\n  all ws : Workstation| all disj w,w1 : Worker | w in ws.workers and w1 in ws.workers and( w in Robot implies w1 in Robot) or (w in Human implies w1 in Human)\n\t// Humans and robots cannot work together\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws: Workstation | one h: Human | h in ws.workers implies !(Robot in ws.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws: Workstation | all h: Human | h in ws.workers implies !(Robot in ws.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tone ws: Workstation | all h: Human | h in ws.workers implies !(Robot in ws.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tone ws: Workstation | (Human in ws.workers implies !(Robot in ws.workers)) and\n  \t(Robot in ws.workers implies !(Human in ws.workers))\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome ws: Workstation | (Human in ws.workers implies !(Robot in ws.workers)) and\n  \t(Robot in ws.workers implies !(Human in ws.workers))\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | no w1, w2: Worker | w1 in ws.workers and w2 in ws.workers\n\tand w1 = Robot and w2 = Human\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | no disj w1, w2: Worker | (w1 & w2) in ws.workers and\n  \tw1 = Robot and w2 = Human\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall wo : Workstation | some r : Robot | r in wo.workers implies no (Human & wo.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | w.workers in Human and w.workers not in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\n  all ws : Workstation |  ws.workers in Human implies ws.workers in Robot \n  \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some(Robot & w.workers) implies Human not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | ws.workers in Human || ws.workers not in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | all h: Human | all r: Robot | h in w.workers implies r in w.workers \n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tone ws : Workstation | (ws.workers = Human) or (ws.workers = Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w : Worker | ((w.workers in Human) iff (w.workers not in Robot)) and ((w.workers in Robot) iff (w.workers not in Human))\n}",
                    "{\n\t// Humans and robots cannot work together\n\t(all ws:Workstation | all w:Worker | w in ws.workers and w in Human) \n\t\tor\n\t(all ws:Workstation | all w:Worker | w in ws.workers and w in Robot)\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno ws:Workstation | all w:Worker | w in ws.workers and (w in Human or w in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall wo : Workstation | some w : Worker, r : Robot | wo in workers.w\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall wo : Workstation | some w : Worker, r : Robot | wo in workers.w implies r not in workers.w\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation | w.workers = Human - Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Worker, wo : Workstation | w in Human and w in wo.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation | no w.workers & Human + Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w: Worker, wst: Workstation | Human in wst.workers implies Robot not in wst.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  //all h: Human, r: Robot, wst: Workstation | h in wst.workers implies r not in wst.workers\n  all h: Human, r: Robot, wst: Workstation | h in wst.workers iff r not in wst.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n\t//all x:Workstation | (Human in x.workers implies Robot not in x.workers) iff (Robot in x.workers implies Human not in x.workers)\n\tall x:Workstation | some y: Worker | some x.workers implies (x in Robot or x in Human)\t\n}",
                    "{\n\t// Humans and robots cannot work together\n\t//all x:Workstation | (Human in x.workers implies Robot not in x.workers) iff (Robot in x.workers implies Human not in x.workers)\n\tall x:Workstation | some y: Worker | some x.workers implies (y in Robot or y in Human)\t\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1 : Workstation | some disj W1, W2 : Worker {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1 + WS1->W2\n        no succ\n\n        Worker = W1 + W2\n        Human = W1\n        Robot = W2\n\n        no Product\n        no Material\n        no Component\n        no Dangerous\n\n        no parts\n        no workstation\n\n        // Negative: WS1 has both a Human (W1) and a Robot (W2) working together, violating \"Humans and robots cannot work together\".\n        // Other requirements satisfied: every workstation has workers (WS1 has W1 and W2); each worker works in exactly one workstation; there are no components or materials, so component/material constraints hold vacuously.\n    }\n} for 1 Workstation, 2 Worker, 0 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2, W3 : Worker | some disj C1 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS1->W2 + WS2->W3\n        succ = WS1->WS2\n\n        Worker = W1 + W2 + W3\n        Human = W1 + W3\n        Robot = W2\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        no Dangerous\n\n        parts = C1->M1\n        workstation = C1->WS2\n\n        // Negative: WS1 has both a Human (W1) and a Robot (W2) working together, violating \"Humans and robots cannot work together\".\n        // Other requirements satisfied: each workstation has workers (WS1 has W1,W2; WS2 has W3); each worker works in exactly one workstation; component C1 has parts (M1) and is assembled in exactly one workstation (WS2); material M1 has no parts.\n    }\n} for 2 Workstation, 3 Worker, 2 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3, W4 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        workers = WS1->W1 + WS2->W2 + WS2->W3 + WS3->W4\n        succ = WS1->WS2 + WS2->WS3\n\n        Worker = W1 + W2 + W3 + W4\n        Human = W1 + W3\n        Robot = W2 + W4\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        no Dangerous\n\n        parts = C1->M1 + C2->M1\n        workstation = C1->WS1 + C2->WS2\n\n        // Negative: WS2 has both a Human (W3) and a Robot (W2) working together, violating \"Humans and robots cannot work together\".\n        // Other requirements satisfied: every workstation has workers (WS1: W1, WS2: W2,W3, WS3: W4); each worker works in exactly one workstation; each component (C1,C2) has parts (M1) and is assembled in exactly one workstation; material M1 has no parts.\n    }\n} for 3 Workstation, 4 Worker, 3 Product expect 0",
                "input tokens": 3297,
                "output tokens": 5761
            },
            {
                "description": "Components cannot be their own parts",
                "pred": "this/inv6",
                "oracle": "{\n\t// Components cannot be their own parts\n\tall c: Component | c not in c.^parts\n}",
                "erroneous": [
                    "{\n  // Components cannot be their own parts\n  all c: Component | c not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n    all c:Component | c not in c.*(parts)\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts=c.parts-Component\n  \n}",
                    "{\n\t// Components cannot be their own parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | c not in c.parts and c not in c.parts.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \tone c:Component | c not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | no c.parts\n  \n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Product | c not in c.parts\n  \n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | c.parts != c\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall x,y,z: Component| (y in x.parts and z in y.parts ) implies x not in (z.parts) \n\n}",
                    "{\n\t// Components cannot be their own parts\n  //all c:Component | some c.parts\n\t//all c:Component | c not in c.parts\n Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts not in c\n}",
                    "{\n\t// Components cannot be their own parts\n  \tsome c:Component | c not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Component | c not in c.parts\n  \tall a,b : Component | a in b.parts implies b not in a.parts\n  \n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts not in Component\n}",
                    "{\n\t// Components cannot be their own parts\n  \tno c: Component | no p: Product | p in c.parts and p = c\n\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some c.parts\n\tall c:Component | c not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Component | c not in Product.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | no p.*parts\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | all p: c.parts | c not in p iff p not in parts.c\n\t//all c1, c2:Component | c1=c2 implies c1 not in c2.parts\n  //no Component.parts\n //Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component, d: Dangerous | c not in Component and d not in Dangerous\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall p : Product | not p in p.parts implies p in Component\n}",
                    "{\n\t// Components cannot be their own parts\n\tall disj c, p: Component | c not in p.parts && p not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Product | not c->c in parts\n\tall c1,c2 : Product | (c1!=c2 and c1->c2 in parts) implies not c2->c1 in parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | \n  \t\t(p in Component) implies (some c: Component |  p not in c.parts)\n}",
                    "{\n\t// Components cannot be their own parts\n\tComponent.parts not in Component\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Component | Component not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some c.parts\n\tone c:Component | c not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  //all c:Component | some c.parts\n\tone c:Component | c not in c.parts\n  no Component.parts\n //Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  //all c:Component | some c.parts\n\tall c1, c2:Component | c1=c2 iff c1 not in c2.parts\n  //no Component.parts\n //Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some p: c.parts | c not in p iff p not in parts.c\n\t//all c1, c2:Component | c1=c2 implies c1 not in c2.parts\n  //no Component.parts\n //Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some p: c.parts | c not in p and p not in parts.c\n\t//all c1, c2:Component | c1=c2 implies c1 not in c2.parts\n  //no Component.parts\n //Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n     all c : Component | one c & Component.parts \n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c not in c.parts\n  \tall c1 : Component | all c2 : Component | c1 in c2.parts implies c2 in c1.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c1 : Component | all c2 : Component | c1 in c2.parts implies c2 in c1.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tComponent.parts != Component\n}",
                    "{\n\t// Components cannot be their own parts\n\tone c: Component | c not in c.^(parts)\n}",
                    "{\n\t// Components cannot be their own parts\n  \tComponent not in Component.^parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p:Product | p.parts != p\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.parts & p) implies (p in Component or p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.parts & p) implies (p in Component and p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.^parts & p) implies (p in Component and p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.^parts & p) implies (p in Component or p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts = c.^parts-c \n}",
                    "{\n\t// Components cannot be their own parts\n  \tlone c: Component | c not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\nall c1,c2 : Component | (c1!=c2 and c1->c2 in parts) implies not c2->c1 in parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\t(Component <: parts) not in iden\n}",
                    "{\n\t// Components cannot be their own parts\n\t(Component <: parts :> Component) not in iden\n}",
                    "{\n\t// Components cannot be their own parts\n\tno *(Component <: parts :> Component) & iden\n}",
                    "{\n\t// Components cannot be their own parts\n\tno (Component->Component & ^parts)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | no (p & p.parts) iff p in Component\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product |\n  \t\tsome c: Component | p=c implies p not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \n  all p : Product, c : Component  | p->c not in parts implies p = c\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | some p : Product | p.parts not in c\n  }",
                    "{\n\t// Components cannot be their own parts\n  \tall c: (Component + Dangerous) | c.parts & c = none\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | p in p.parts\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1 : Workstation | some disj W1 : Worker | some disj C1 : Component {\n        Workstation = WS1\n        begin = WS1\n        end = WS1\n        workers = WS1->W1\n        no succ\n\n        Worker = W1\n        Human = W1\n        no Robot\n\n        Product = C1\n        no Material\n        Component = C1\n        no Dangerous\n\n        parts = C1->C1\n        workstation = C1->WS1\n\n        // Negative: Component C1 is its own part (C1->C1), violating \"Components cannot be their own parts\".\n        // Other requirements satisfied: WS1 has worker W1 and W1 works in exactly one workstation; workers are all human (no robots); component C1 has parts and is assembled in exactly one workstation (WS1); there are no materials, so \"materials have no parts\" holds; no mixing of humans and robots at any workstation.\n    }\n} for 1 Workstation, 1 Worker, 1 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2, W3 : Worker | some disj C1 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS1->W2 + WS2->W3\n        succ = WS1->WS2\n\n        Worker = W1 + W2 + W3\n        Human = W1 + W2\n        Robot = W3\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        no Dangerous\n\n        parts = C1->C1 + C1->M1\n        workstation = C1->WS2\n\n        // Negative: Component C1 includes itself as a part (C1->C1), violating \"Components cannot be their own parts\".\n        // Other requirements satisfied: WS1 has human workers (W1,W2) and WS2 has a robot worker (W3), so no human-robot mixing; each worker works in exactly one workstation; component C1 has parts and is assembled at exactly one workstation (WS2); material M1 has no parts.\n    }\n} for 2 Workstation, 3 Worker, 2 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3, W4 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        workers = WS1->W1 + WS2->W2 + WS2->W3 + WS3->W4\n        succ = WS1->WS2 + WS2->WS3\n\n        Worker = W1 + W2 + W3 + W4\n        Human = W1 + W4\n        Robot = W2 + W3\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        no Dangerous\n\n        parts = C1->M1 + C2->C2\n        workstation = C1->WS1 + C2->WS2\n\n        // Negative: Component C2 is its own part (C2->C2), violating \"Components cannot be their own parts\".\n        // Other requirements satisfied: each workstation has workers (WS1: W1 human, WS2: W2,W3 robots, WS3: W4 human) with no human-robot mixing; every worker works in exactly one workstation; each component (C1,C2) has parts and is assembled in exactly one workstation; material M1 has no parts.\n    }\n} for 3 Workstation, 4 Worker, 3 Product expect 0",
                "input tokens": 3664,
                "output tokens": 5600
            },
            {
                "description": "Components built of dangerous parts are also dangerous",
                "pred": "this/inv7",
                "oracle": "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | some (c.parts & Dangerous) implies c in Dangerous\n}",
                "erroneous": [
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (o.parts in Dangerous) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (o.^parts in Dangerous) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.^parts) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.parts) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | some p: c.parts | p in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component | Dangerous in c.^parts implies Dangerous in c \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component | some e:c.^(parts)| e in Dangerous implies c in Dangerous }",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component, p : Product | c in p.parts and p in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | (c in Dangerous) implies (c.parts in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | Dangerous in c.parts implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | c.parts in Dangerous \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.parts) implies o = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | (c in Dangerous) implies (c.^parts in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous implies some p: parts.c| p in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component, d: Dangerous | d in c.^parts => c = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous iff some p: c.parts | p in Dangerous\n  \t\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (c in Dangerous) implies (c.~parts in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c, c1 : Component | (c1 in c.parts and c1 in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous implies some p: c.parts| p in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t\tDangerous = {p: Product | some p.parts & Dangerous}\n\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all d : Dangerous | d.parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some p : c.parts| p in Dangerous.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | Dangerous in c implies Dangerous in ^parts.c\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component, d:Dangerous | d in ^parts.c implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (Dangerous in c) implies all p : ^parts.c |\n  Dangerous in p\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | Dangerous in c.^parts => c = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | (some x: c.parts | x in Dangerous) implies (Dangerous in c)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall p: Product | some pp:p.parts | pp in Dangerous implies p in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component |\n  \t\tone p:c.parts|\n  \t\t\tp in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | (c in Dangerous) and (c.parts in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t//all c: Component | c in Dangerous implies some p: c.parts | p in Dangerous\n  \tall c:Component | all p: c.parts| p in Dangerous iff c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | (c.^parts in Dangerous) and c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component |\n  \tone p:c.^parts |\n  \t\tp in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (some c: Component | c.parts in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t//all c: Component | some c.^parts & Dangerous => c in Dangerous\n  \tDangerous in Component implies Dangerous.^parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | one d : Dangerous | d in c.parts => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some p : Dangerous.parts | p in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Product | (c.^parts in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | c in Dangerous implies c.parts in (Dangerous + Material)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component |  (parts.c in Dangerous) implies c in Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component, p : Product | (c.parts in Dangerous) iff (p in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component | c in Dangerous iff c.^parts in Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  some c : Component.parts | all c1 : Component | c1 in c and c in Dangerous implies c1 in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component | Dangerous in c implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | some d: Dangerous | d.parts in c.parts implies c in d\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tDangerous.^parts = Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous iff some p: parts.c | p in Dangerous\n  \t\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t//all c: Component | c in Dangerous implies some p: c.parts | p in Dangerous\n  \tall c:Component | some p: parts.c| p in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.parts)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t//all c: Component | c in Dangerous implies some p: c.parts | p in Dangerous\n  \tall c:Component | some p: c.parts| p in Dangerous iff c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\t//all c:Component | some e:c.^(parts)| e in Dangerous implies c in Dangerous }\n\tall c:Component | some (c.^(parts) & Dangerous) }",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\t//all c:Component | some e:c.^(parts)| e in Dangerous implies c in Dangerous }\n\tall c:Component | some (c.parts & Dangerous) }",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some d : Dangerous | d in c.^parts <=> c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | (c in Dangerous) implies (Dangerous in c.^(parts))\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    //all c : Component | Dangerous in c.^(parts) implies Dangerous in c\n  all c: Component | some p: c.parts | p in Dangerous implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component & Dangerous | Dangerous in c.parts implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | Dangerous in c.~parts implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | one d : Dangerous | d in c.^parts => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | c in Dangerous iff Dangerous in c.^parts\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | c in Dangerous iff some Dangerous & c.^parts\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | all p: c.parts | p in Dangerous and c in Dangerous \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | all p: c.parts | (p in Dangerous and c in Dangerous) or (c in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some c1 : Component | (c1 in c.^parts and c1 in Component) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c, c1 : Component | (c1 in c.^parts and c1 in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some p : c.parts&Dangerous | c in Dangerous\n  \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component | Dangerous in c.parts implies c in Dangerous\n\t\n  all c : Component | lone p : Product | p in c.parts and p in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  //all c : Component | Dangerous in c.parts implies c in Dangerous\n\t\n  all c : Component | lone p : Product | p in c.parts and p in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tsome d: Dangerous | some c: Component| d in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    ((Component - Dangerous) -> Dangerous) not in parts\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | not (c.^parts in Dangerous) implies c  in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (some c: Component | c.^parts in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tno c: Component | some c.parts & Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall p: Product | (p in Dangerous) <=> some p2: Product | p2 != p and p2 in p.parts and p2 in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tDangerous & Component.^parts = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\t\tall c:Component | ^parts.c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall p: Product | Dangerous in p.^parts => p in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component, p : Product | p in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component, p : Product | p.parts in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component | c in Dangerous implies parts.Product in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component | no c.*parts & Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component | no c.^parts & Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component, d:Dangerous| d.parts in c.parts implies c in d\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component, d:Dangerous| d.parts in c.parts implies c = Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component, d:Dangerous| d.parts in c.^parts implies c = Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | Dangerous in c.parts implies c.parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | one d: Dangerous| d in c.parts implies c.parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | c.parts in Dangerous.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | all p : Dangerous.parts | p in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | one p : Dangerous.parts | p in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some p : Dangerous.parts | p in c.parts iff c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some ( c.^(parts.parts) & Dangerous ) implies c in Dangerous\n\t\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (Dangerous in c) implies (Dangerous in parts.c)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (Dangerous in c) implies ^parts.c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component | c in Dangerous iff c.parts in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | Dangerous in c.parts implies Dangerous in Component\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tsome c: Component | c.parts in Dangerous => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tsome c: Component | some (c.parts & Dangerous) => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some d : Dangerous | d in c.parts implies c in d.parts\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some d : Dangerous | Dangerous = c.parts implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall p : Product | p in Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component, p : Product | (c.parts in Dangerous) iff (p.parts in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component|one c.parts & Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | some d: Dangerous | d in c.parts =>\n  \t\tall p: c.parts | p in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  some c : Component.parts | all c1 : Component | c1 in c \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  //some c : Component.parts | all c1 : Component | c in c1 and c in Dangerous implies c1 in Dangerous\n  some c : Component | c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component, p : Product | c in p.parts implies (c in Dangerous and p in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some (c.parts & Dangerous) implies no (c.parts & (Product - Dangerous))\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2 : Worker | some disj C1 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2\n        succ = WS1->WS2\n\n        Worker = W1 + W2\n        Human = W1 + W2\n        no Robot\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        Dangerous = M1\n\n        parts = C1->M1\n        workstation = C1->WS1\n\n        // Negative: C1 has dangerous part M1 (M1 in Dangerous) but C1 is not dangerous, violating \"Components built of dangerous parts are also dangerous\".\n        // Other requirements satisfied: each workstation has workers (WS1: W1, WS2: W2); every worker works in exactly one workstation; all workers are human (no human-robot mixing); C1 has parts and M1 has no parts; no component is its own part.\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2 + WS2->W3\n        succ = WS1->WS2\n\n        Worker = W1 + W2 + W3\n        Human = W1\n        Robot = W2 + W3\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        Dangerous = C2\n\n        parts = C1->C2 + C2->M1\n        workstation = C1->WS1 + C2->WS2\n\n        // Negative: C1 has dangerous part C2 (C2 in Dangerous) yet C1 is not dangerous, violating \"Components built of dangerous parts are also dangerous\".\n        // Other requirements satisfied: WS1 has a human (W1) and WS2 has robots (W2,W3) with no mixing; each worker works in exactly one workstation; both components (C1,C2) have parts; material M1 has no parts; no component is its own part.\n    }\n} for 2 Workstation, 3 Worker, 3 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1, M2 : Material {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        workers = WS1->W1 + WS2->W2 + WS3->W3\n        succ = WS1->WS2 + WS2->WS3\n\n        Worker = W1 + W2 + W3\n        Human = W1 + W3\n        Robot = W2\n\n        Product = C1 + C2 + M1 + M2\n        Material = M1 + M2\n        Component = C1 + C2\n        Dangerous = M1\n\n        parts = C1->M1 + C2->M2\n        workstation = C1->WS1 + C2->WS3\n\n        // Negative: C1 has dangerous part M1 (M1 in Dangerous) but C1 is not dangerous, violating \"Components built of dangerous parts are also dangerous\".\n        // Other requirements satisfied: each workstation has exactly one worker and no human-robot mixing (WS1: human W1, WS2: robot W2, WS3: human W3); each worker works in exactly one workstation; both components have parts; materials M1 and M2 have no parts; no component is its own part.\n    }\n} for 3 Workstation, 3 Worker, 4 Product expect 0",
                "input tokens": 3735,
                "output tokens": 7325
            },
            {
                "description": "Dangerous components cannot be assembled by humans",
                "pred": "this/inv8",
                "oracle": "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: (Component & Dangerous) | no c.workstation.workers & Human\n}",
                "erroneous": [
                    "{\n\t// Dangerous components cannot be assembled by humans\n    \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Human not in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall d:Dangerous| d.workstation.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component | (c in Dangerous) implies (c.workstation.workers in Human)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Robot in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \t//all c: Component| c in Dangerous implies no workers.Human in c.workstation\n  all c:Component| c.workers in Human implies c in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, ws: Workstation |\n  \t\tws.workers in Human => c not in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | all work: c.workstation | c in Dangerous implies Human not in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, h: Human, ws: Workstation | c in Dangerous implies (not h in ws.workers) \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component | some c.parts & Dangerous => no c.workstation.workers & Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all h : Human, p : Product | p in Dangerous implies no workers.h\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component| all w: Worker| c in Dangerous iff w in Human\n  //all c:Component| c.workers in Human implies c in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Robot in o.workstation.workers)\n  \tall o: Component | (o in Dangerous) implies (Human not in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall x: Workstation | workstation.x in (Component & Dangerous) implies x.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n    workers.Human & Dangerous.parts.workstation = none\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, h: Human|\n  \t\t(c in Dangerous) implies (some p: h.workstation | p not in c.workstation)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall d:Dangerous| Human not in d.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous implies no (c.workstation.workers)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all r: Robot | all w: Workstation |( c in Dangerous and w in c.workstation )implies r in w.workers\n}",
                    "{ \n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all wo: Workstation |all p: Product | all w: Worker| p in Dangerous and p in c.parts and wo in c.workstation and w in wo.workers implies w in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Human not in o.workstation)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | all work: c.workstation | Human not in work.workers implies c in Dangerous \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | all work: c.workstation | c in Dangerous iff Human not in work.workers and Robot in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n        all w : Workstation, c : (Component & Dangerous) | w.workers in Robot\n\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tHuman not in Dangerous.workers\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \t(parts.Dangerous).workers not in Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \t((Dangerous.workstation).workers) not in Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component | no h : Human | c in Dangerous => h in c.workstation\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | some wo: Workstation | (c in Dangerous implies wo.workers not in Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tHuman not in Dangerous.workstation.^workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall d: Dangerous | d in Component and d.workstation.workers in Robot\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c : Component | no c.workstation.workers & Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation, r : Robot | c in Dangerous implies w.workers in r\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p: Product, ws: Workstation | some h: Human |\n  \t\th in ws.workers => p not in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p: Product, ws: Workstation | some h: Human |\n  \t\t(h in ws.workers) and (ws in p.workstation) => (p not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n      all h: Human, c: Dangerous | h in c.workstation\n\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | all ws : c.workstation | ws.workers in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, wst: Workstation | c in Dangerous implies wst.workers in c.workstation and wst.workers not in Human \n}",
                    "{\n  // Dangerous components cannot be assembled by humans\n  all w: Workstation | Dangerous in workstation.w.parts implies no w.workers & Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component| all w: Worker| c in Dangerous implies w in Human\n  //all c:Component| c.workers in Human implies c in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t//all o: Component | (o in Dangerous) implies (Robot in o.workstation.workers)\n  \t//all o: Component | (o in Dangerous) implies (Human not in o.workstation.workers)\n\tall o: Component, h: Human | some r: Robot | (o in Dangerous) implies (h not in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | all work: c.workstation | c in Dangerous iff Human not in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | some work: c.workstation | Human not in work.workers implies c in Dangerous \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  some c:Component | all work: c.workstation | c in Dangerous implies Human not in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | all work: c.workstation | c in Dangerous implies Human not in work.workers and Robot in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | all work: c.workstation | c in Dangerous iff Robot in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | some work: c.workstation | c in Dangerous iff (Human not in work.workers and Robot in work.workers)\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  //all c: Component| all w: Worker| w in Human implies c in Dangerous\n  //all c:Component| c.workers in Human implies c in Dangerous\n  all c:Component | some work: c.workstation | c in Dangerous iff no Human & work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component, w:Workstation | Dangerous in c.^parts implies w.workers not in Human \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component, w:Workstation | Dangerous in c.^parts implies Human not in w.workers \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component, w:c.workstation | Dangerous in c.^parts implies Human not in w.workers \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | (c in Dangerous) implies all w: Worker | w in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  no d:Dangerous | no (Human & (d.^parts & Component).workstation.workers)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|\n  \tc in Dangerous and c.workstation not in\t(workers.Human))\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|\n  \tc in Dangerous and c.workstation not in (Workstation - workers.Human))\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|\n  \tc in Dangerous and c.workstation not in (Workstation - workers.Robot))\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|all ws: Workstation|\n  \tc in Dangerous and c.workstation in ws and no ws.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c:Component | (c in Dangerous) implies (c.workstation in Robot)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p : Product, ws : Workstation | ws.workers in Robot implies p in Dangerous\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p : Product, ws : Workstation | p in Dangerous implies ws.workers in Robot  \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p : Product, ws : Workstation | p in Dangerous and ws.workers in Robot  \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n    all c:Dangerous | some (c.workstation.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous iff no Human & c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous iff c.workstation.workers in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | (c.^parts in Dangerous) implies Robot in c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | (c.^parts in Dangerous) implies c.workstation.workers in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component | no h : Human | c in Dangerous => h in c.workstation.workers\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, ws : Workstation | (c.parts & Dangerous) not in (ws.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall  d: Dangerous | some w : Workstation| w = d.workstation and w.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c: Dangerous | no w: Worker | w in Human and c.workstation in w\n\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d: Dangerous | Human not in Dangerous.parts\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t//all c: Component, h: Human | c in Dangerous => h not in c.workstation.workers\n  \tall c: Component, h: Human | c in Dangerous => Human not in c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws: Workstation, h: Human|\n  \t\t(h in ws.workers) implies (some c: Component |c->ws in workstation implies c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t// all d : Dangerous | no (d.workstation).workers & Human \n  \tno h : Human | h not in (Dangerous.workstation).workers \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d:Dangerous, ws:Workstation |  Human not in ws.workers implies ws in d.workstation\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d:Dangerous, ws:Workstation | ws in d.workstation and Human not in ws.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c: Component | c in Dangerous implies c.workstation.workers != Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | Dangerous in c implies\n  no Human & c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation, r : Robot | c = Dangerous implies w.workers in r\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation.workers | c in Dangerous implies Robot in w.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, ws: Workstation | some h: Human |\n  \t\th in ws.workers => c not in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, ws: Workstation | some h: Human |\n  \t\t(h in ws.workers and ws in c.workstation) => (c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws: Workstation | some h: Human, c: Component |\n  \t\t(h in ws.workers and ws in c.workstation) => (c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws: Workstation, h: Human | some c: Component |\n  \t\t(h in ws.workers and ws in c.workstation) => (c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all p: Product | all w: Worker| p in Dangerous and p in c.parts implies w in Robot\n}",
                    "{ \n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all wo: Workstation |some p: Product | all w: Worker| p in Dangerous and p in c.parts and wo in c.workstation and w in wo.workers implies w in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws : Workstation | some d : (Component & Dangerous) | ws in d.workstation implies Human not in ws.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws : Workstation | some d : Dangerous | ws in d.workstation implies Human not in ws.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws : Workstation | some d : Dangerous | ws in d.workstation implies ws.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component, h : Human | (c.workstation in Human) iff (c in Dangerous)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component, h : Human | (c.workstation.workers in Human) iff (c in Dangerous)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component, h : Human | (c.workstation.workers not in Human) iff (c in Dangerous)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, p: Product, h: Human, ws: Workstation | p in Dangerous implies (not h in ws.workers) \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, p: Product, h: Human, ws: Workstation | c->p in parts and p in Dangerous implies (not h in ws.workers) \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, h : Human, wo : Workstation | c in workstation.wo\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c : Component | Dangerous in c implies Human not in c.workstation\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c : Component | Dangerous in c implies Human not in c.workstation.workers\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, wst: Workstation | c in Dangerous implies wst.workers not in c.workstation \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous => c.workstation.workers = Human\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2 : Worker | some disj C1 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2\n        succ = WS1->WS2\n\n        Worker = W1 + W2\n        Human = W1 + W2\n        no Robot\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        Dangerous = C1\n\n        parts = C1->M1\n        workstation = C1->WS1\n\n        // Negative: C1 is a dangerous component assembled at WS1, which has human workers (W1). Violates \"Dangerous components cannot be assembled by humans\".\n        // Satisfies: all workers are Human or Robot (here all Human); every workstation has workers and each worker is in exactly one workstation; each component has exactly one workstation; components have parts and materials have no parts; no human-robot mixing per workstation; no component is its own part; components with dangerous parts are dangerous (no dangerous parts here).\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS1->W2 + WS2->W3\n        succ = WS1->WS2\n\n        Worker = W1 + W2 + W3\n        Human = W1 + W2\n        Robot = W3\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        Dangerous = C1\n\n        parts = C1->M1 + C2->M1\n        workstation = C1->WS1 + C2->WS2\n\n        // Negative: C1 is dangerous and assembled at WS1 with only human workers (W1,W2). Violates \"Dangerous components cannot be assembled by humans\".\n        // Satisfies: Worker = Human + Robot; each workstation has workers and each worker is assigned to exactly one; each component has exactly one workstation; both components have parts and the material has no parts; no human-robot mixing per workstation (WS1 only humans, WS2 only robots); no component is its own part; components with dangerous parts are dangerous (no dangerous parts used).\n    }\n} for 2 Workstation, 3 Worker, 3 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1, M2 : Material {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        workers = WS1->W1 + WS2->W2 + WS3->W3\n        succ = WS1->WS2 + WS2->WS3\n\n        Worker = W1 + W2 + W3\n        Human = W2\n        Robot = W1 + W3\n\n        Product = C1 + C2 + M1 + M2\n        Material = M1 + M2\n        Component = C1 + C2\n        Dangerous = C2\n\n        parts = C1->M2 + C2->M1\n        workstation = C1->WS3 + C2->WS2\n\n        // Negative: C2 is dangerous and assembled at WS2, which has a human worker (W2). Violates \"Dangerous components cannot be assembled by humans\".\n        // Satisfies: Worker = Human + Robot; every workstation has exactly one worker and each worker is in exactly one workstation; each component has exactly one workstation; components have parts and materials have no parts; no mixing of humans and robots per workstation (WS1/WS3 robots, WS2 humans); no component is its own part; components with dangerous parts are dangerous (no dangerous parts used).\n    }\n} for 3 Workstation, 3 Worker, 4 Product expect 0",
                "input tokens": 3866,
                "output tokens": 7751
            },
            {
                "description": "The workstations form a single line between begin and end",
                "pred": "this/inv9",
                "oracle": "{\n\t// The workstations form a single line between begin and end\n  \n  \tall w : Workstation | w in begin.*succ\n  \n  \tall w : Workstation - end | one w.succ\n  \n  \tno end.succ\n\t\n}",
                "erroneous": [
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \t(Workstation-begin) in begin.*succ\n  \tall w:Workstation | w not in w.*succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | \n \t\twStart not in w.^succ\n  \tall wStart: (Workstation & begin) - end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.^succ\n  \tall w: Workstation | no w.succ implies w in begin\n  \tall w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all ws : Workstation | ws in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tno succ.begin\n  \n\tno end.succ\n  \n  \tall w : Workstation | w not in w.^succ\n  \t\n  \tall w : Workstation-begin-end | one w.succ and one succ.w\n  \n  \tend in begin.*succ\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: (Workstation+begin+end) | w in begin.*succ and w not in end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w1 : Workstation, w3 : Workstation | all w2 :  Workstation - w1 - w3 |  w2 & w3 in w1.^succ && w2 & w1 in w3.^succ && #(w2.succ) = 1\n  \t \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one begin.^succ & w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: (Workstation+begin+end) | w in begin.*succ\n  \tall w: (Workstation+begin+end) | w not in end.^succ\n  \tall w: (Workstation+begin+end) | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws in begin.*succ and end in ws.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin.^succ = Workstation - begin\t\t\t\t\t\t// begin has all workstations as succ\n  \t//all w : Workstation | w not in w.succ and lone w.succ\t// No workstation has itself as succ and every workstation has only one succ\n  \tno end.succ\t\t\t\t\t\t\t\t\t\t\t\t// end does not have any workstations as succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^succ\n  \t//all w: begin.^succ | begin not in w.^succ and w not in w.^succ and end in w.^succ\n  \tno end.succ\n  \tno succ.begin\n  \tall w: Workstation - end | one w.succ and w not in w.^succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w not in end) implies one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no end.succ\n  Workstation in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | one begin.succ & w and one w.^succ & end and (w not in w.^succ or w in end)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation = begin.*succ\n  \tWorkstation = end.*(~succ)\n  \t\n  \tall ws:Workstation - end - begin | one ws.succ and one ws.~succ\n  \n  \tall ws:Workstation | ws not in ws.^succ\n  \n  \tone end.~succ\n  \tno end.succ\n  \n  \tone begin.succ\n  \tno begin.~succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = end or some w.succ) and (w != end implies one w.succ) and (w != begin implies one w.~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws not in ws.^succ\n  \tall ws1, ws2 : Workstation | ws1 != ws2 implies ws1 in ws2.^succ or ws2 in ws1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno begin.~succ\n  \tno end.succ\n  \tall s: Workstation - end | one s.succ\n  \tall s: Workstation - begin | one s.~succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | one b: begin, e: end | e in ws.^succ and ws in b.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | one b: begin, e: end | (e in ws.*succ or e=ws) and (ws in b.*succ or b=ws) and ws not in ws.succ\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | one w.~succ and one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno succ.begin\n  \tno end.succ\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ)   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | w not in end implies one w.succ\n  no end.succ\n  all w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w in begin.*succ\n  \n      // Todas as workstations exceto a \u00faltima tem exatamente uma a seguir\n      all w : Workstation - end | one w.succ\n  \n      // A \u00faltima workstation n\u00e3o tem nenhuma a seguir\n      //no end.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^{succ}\n  \tall e: end, b: begin | (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | some sub:Workstation| sub in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend not in ^succ.Workstation\n  \tall s: Workstation | s not in s.^succ\n  \tall w: Workstation - begin - end |\n  some w.^succ and some ^succ.w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation - end | one w.succ\n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end | one(W.succ) and W.succ != W \n  \t\n  \tall W : Workstation - begin| one (succ.W) and succ.W != W\n\t\n  \tend.succ   = none\n  \tsucc.begin = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \t//desnecess\u00e1rio \n  \tall ws : Workstation | ws not in ws.succ\n  \tall ws:Workstation -end | one ws.succ\n  \tall b : begin, ws : Workstation | b not in ws.succ\n  \tall e : end | no e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \tall w : begin | some w2 : Workstation | w!=w2 implies some w.succ and no succ.w\n  \tall w : end | some w2 : Workstation | w!=w2 implies some succ.w and no w.succ\n  \t//some begin <: ^succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end or w in begin \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, e: end | e in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  not (begin.succ = end) and begin.^(succ) = end  or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsucc in (Workstation one -> one Workstation) and end in begin.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: begin | one w2: Workstation | w2 in ws.succ\n  \n  \tall ws: end | no w2: Workstation | w2 in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ & iden\n  \tall w : Workstation-end | one w.succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | some (begin & end) implies some w.succ and w not in w.^succ\n  //all w: Workstation| one (begin & end) implies no w.succ\n  //each workstation only has one or no succ\n  //all w: Workstation | lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation|ws in begin+end or ws in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone begin <: succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ) and end in (ws.*succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation| one(W.succ) and W.succ != W\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - end |\n  \t\tone ws.succ\n  \n    end.succ = none\n  \n  \tsucc.begin = none\n  \n  \n  }",
                    "{\n\t// The workstations form a single line between begin and end\n  \t// n\u00e3o pode se referenciar \u00e0 propria nem \u00e0s suas descendentes\n  \tall w : Workstation | w not in w.^succ and lone (w.succ)\n  \tall w : (Workstation - begin) | w in Workstation.succ\n  \t\n  //\tbegin not in Workstation.succ\n  //\tno end.succ\n  \t\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | some su:ws.succ | ws = begin implies su = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and no(begin & end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tall ws: (Workstation-begin-end) | some(ws.succ)\n  \tno(succ.begin) and no(end.succ)   \n  \t(begin != end) implies some(succ.end) and some(begin.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : Workstation | begin in w + w.~succ\n  \tall w : Workstation | end in w + w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \tall w : begin | some w2 : Workstation | w!=w2 implies (some w.succ and no succ.w)\n  \tall w : end | some w2 : Workstation | w!=w2 implies (some succ.w and no w.succ)\n  \tsome begin <: ^succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws not in ws.^succ and (ws.succ != none iff ws != end)\n  \tall disj w1, w2: Workstation | w1.succ & w2.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | (ws not in end implies #ws.succ=1) and ws not in ws.succ\n  \tone ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all w: Workstation | w not in w.^succ)\n\tand (all w1, w2: Workstation | w1 in w2.succ implies w2 not in w1.^succ)\n\tand (all w: Workstation | w = begin or w in begin.^succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all s: Workstation | lone s.succ\n    all s: Workstation | s in begin.*succ\n    //end.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n\tall w:Workstation | w in begin implies (lone w.succ and no succ.w)\n\tall w:Workstation | w in end implies (no w.succ and lone succ.w)\n\tall w:Workstation | w not in (begin + end) implies (one w.succ and one succ.w and w not in w.succ and w not in succ.w)\n\tsome b: Workstation | b in begin implies b.*succ in end\n  \n  \n  \n  //\tall w : Workstation | ((w in begin) implies (one(w.succ) and no(succ.w)) and\n  // ((not(w in begin + end) implies (one(w.succ) and one(succ.w))) and\n //((w in end) implies ((one(succ.w) and no(w.succ)) and\n  // not(w in succ.w))) or (one(Workstation) and no(w.succ) and no(succ.w)) and (w not in w.^succ) and (w not in succ.w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | (w in end or w in begin or w in w1.succ) and w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: (Workstation+begin+end) | no begin.^succ & w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all ws:Workstation | one b:begin | one e :end | ws in b.succ and e in ws.succ \n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws.succ != ws\n  \tend in begin.*succ \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  begin + begin.^succ = Workstation and end.succ = none\n  no ws : Workstation | ws.succ = ws\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tno end.succ\n  \tone Workstation.succ\n  \tWorkstation in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tall e: end, b: begin | ((e = b) and (#Workstation =< 1)) or (e in b.^succ)\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | one w.succ and one w.~succ\n    no begin.~succ and no end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n  \tall w : Workstation - begin | one s : Workstation | w in s.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ and all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end) and ws not in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tone e: end, b: begin | (e = b) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | begin in ws.^succ and end in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tsome w: Workstation | w.succ = end || w=end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | wStart not in w.^succ\n  \tall wStart: (Workstation & begin)-end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w not in w.succ\n  \n    all w : Workstation | ( w = begin implies (some w1:Workstation | w->w1 in succ)) and (w = end implies (one w2: Workstation | w2->w in succ) ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n    // 1. Nenhuma esta\u00e7\u00e3o pode apontar para si mesma\n    all w : Workstation | w -> w not in succ\n\n    // 2. `begin` deve ter exatamente uma esta\u00e7\u00e3o sucessora\n    one w1 : Workstation | begin -> w1 in succ\n\n    // 3. `end` deve ter exatamente uma esta\u00e7\u00e3o predecessora\n    one w2 : Workstation | w2 -> end in succ\n\n    // 4. Todas as esta\u00e7\u00f5es intermedi\u00e1rias devem ter exatamente uma predecessora e uma sucessora\n    all w : Workstation - begin - end |\n        (one w1 : Workstation | w -> w1 in succ) and\n        (one w2 : Workstation | w2 -> w in succ)\n\n    // 5. Todas as esta\u00e7\u00f5es devem ser acess\u00edveis a partir de `begin`\n    all w : Workstation | w in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, e: end | e in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t all w : Workstation | one ww : Workstation| ww in w.^succ \n\n}",
                    "{\n  all ws: Workstation | ws not in ws.^succ \n  and all ws1 : Workstation |  ws1 in ws.succ implies ws1 not in ws.^succ\n\t// The workstations form a single line between begin and end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \tWorkstation in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  // Every workstation (except end) has at most one successor\n  all w: Workstation - end | one w.succ\n\n  // Every workstation (except begin) has at most one predecessor\n  all w: Workstation - begin | one w.~succ\n  \n  all w: Workstation | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tone e: end, b: begin | ((e = b) and (#Workstation = 1)) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^{succ}\n  \tall e: end, b: begin | (e = b implies no e.succ) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies (all w : Workstation-end | one w.succ) and (begin.^succ = Workstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and no(begin & end) and (not(w in w.succ) and not(w in succ.w))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | (one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and (not(w in w.succ) and not(w in succ.w))) or (one(Workstation) and no(w.succ) and no(succ.w))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    (Workstation = begin and begin = end and no(begin.succ)) or \n  \t(all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end) and ws not in ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | ((w in end) and (w not in w.succ) and (end in begin.succ)) or ((w in begin) and (w not in w.succ)) or (w in w1.succ) or ((w in begin) and (w in end) and (end in begin.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | ((w in end) and (w not in w.succ) and (end in begin.succ)) or ((w in begin) and (w not in w.succ)) or (w in w1.succ) or ((w in begin) and (w in end) and (w not in w.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one Workstation => no succ else one begin.succ and one succ.end and (all w: Workstation - begin - end | one w.succ and one succ.w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  one w : Workstation | begin in w\n  one w : Workstation | end in w and no w.succ\n  all w : Workstation | no (begin & end)\n  all w : Workstation-begin-end | one succ.w and one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  one w : Workstation | begin in w\n  one w : Workstation | end in w and no w.succ\n  all w : Workstation-begin-end | one succ.w and one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n    begin != end implies all w : Workstation | w != begin and w != end implies w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | lone w.succ\n\tno end.succ\n  \n  \tbegin not in Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation - end | lone w.succ\n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno s: Workstation | s -> s in workstation\n  \tall s: Workstation - begin - end {\n      \tone s.~workstation.parts.workstation\n  \t}\n\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - end |\n        lone w.~succ and (w in begin.~succ or one w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - end | ws in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tlet line = Workstation - begin - end {\n        all ws: line | one ws.succ and ws.succ in line\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n  \tall w : Workstation - begin | one s : Workstation | w in s.succ\n  \tbegin = end => no s : Workstation | s in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end or begin = end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (end in begin.^(succ) or begin = end) and all ws : Workstation | ws.succ != ws and ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end implies one Workstation\n  (end = begin.^(succ) or begin = end) and begin.succ != begin \n  and all ws : Workstation | ws in (begin + begin.^(succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = begin or w in begin.^succ) and (w = end or end in w.^succ) and one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wk : Workstation | one b : begin | wk=b or wk in b.^succ\n  \tall wk : Workstation | one e : end | wk=e or e in wk.^succ\n  \tall wk : Workstation | wk not in wk.succ and lone wk.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - end | one w.succ\n    all w: Workstation - begin | one w.~succ\n  \tWorkstation = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n\t(all ws: Workstation| ws not in ws.succ) and\n\tend in begin.^succ \n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n    all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wk : Workstation | one wk.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | \n  \tall wStart: (Workstation & begin) |\n  \tsome wEnd: (Workstation & end) | \n  \t\twStart not in w.succ and wStart not in end implies wEnd in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | some ws.succ iff ws in begin-end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | one ws.succ iff ws in begin-end\n  \tall ws: Workstation | no (ws & ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend in Workstation.^succ or (lone Workstation)\n  \t\n}",
                    "{\n all ws: Workstation | lone ws1 : Workstation | ws not in ws.^succ and ws1 !=ws and ws1 in ws.succ\n\n// The workstations form a single line between begin and end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w1 : Workstation | one  w2 : Workstation , w3 : Workstation | w1 in w2.succ && w3 in w1.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone wt : Workstation | all wts : Workstation | wt not in wts.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tno end.succ\n  \tend in begin.^succ or end in begin\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1 : Workstation | some ws2 : Workstation | ws2 in begin implies ws1 in ws2.^(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w not in begin and w not in end) implies some w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation |  #w.succ = 1 and (w != begin implies w in begin.*succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \tall ws: Workstation - begin | ws in begin.*succ \n     \n    no end.succ \n    no ws: Workstation | ws in ws.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | w in begin.*succ and w in ^succ.end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.^(succ)\n  \tbegin & end != none implies #(begin.succ) = 0\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation in begin.*succ\n  \tiden not in succ\n  \tall wo : Workstation | wo.succ not = none => begin not = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc - iden = succ\n  \tWorkstation in begin.*succ\n  \tbegin.succ not = none => end in begin.^succ\n  \tiden not in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \tWorkstation in (begin.*succ & *succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome wo: Workstation | begin in wo and end in wo.*succ\n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  Workstation - begin = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t// Only 'begin' has no predecessor\n  no w: Workstation - begin | one w.~succ\n  \n  // Only 'end' has no successor\n  no w: Workstation - end | one w.succ\n\n  // Every workstation (except end) has at most one successor\n  all w: Workstation - end | lone w.succ\n\n  // Every workstation (except begin) has at most one predecessor\n  all w: Workstation - begin | lone w.~succ\n  \n  all w: Workstation | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    succ in Workstation -> lone Workstation\n    one w : Workstation | no w.succ\n    all w : Workstation | not w in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one begin.succ\n  all w: Workstation | w not in end implies one w.succ\n  no end.succ\n  all w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | no (begin & end) implies lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | lone w.succ implies no (begin & end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | one w.succ implies lone (begin & end)\n  all w: Workstation| one (begin & end) implies no w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^{succ}\n  \tall e: end, b: begin | e = b\n  \tone e: end, b: begin | (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^{succ}\n  \tall e: end, b: begin | (e = b and no e.succ) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | some (begin & end) implies some w.succ\n  all w: Workstation | w not in w.^succ\n  //all w: Workstation| one (begin & end) implies no w.succ\n  //each workstation only has one or no succ\n  //all w: Workstation | lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^succ\n  \tall w: begin.^succ | w not in w.^succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one disj c1, c2:Workstation | (c1 in begin) and (c2 in end) and (c1.^succ = Workstation - c1) and no(c2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (one disj c1, c2:Workstation | (c1 in begin) and (c2 in end) and (c1.^succ = Workstation - c1) and no(c2.succ)) or (one c1:Workstation | (c1 in begin) and (c1 in end))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,e : Workstation | e in b.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | w not in w.succ\n    all w : Workstation | w in begin implies w not in end\n    all b : begin, e : end | b not in e.succ\n  \tall e : end | no e.succ\n    all w : Workstation | w not in end implies one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - (begin & end)| one (W.succ) and no (W.succ & W &begin)\n  \tand (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    Workstation = begin or (all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end) and ws not in ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(one w:Workstation | w in begin) and (one w:Workstation | w in end) and (all w:Workstation | some succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | w in end or w in begin or w in w1.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation |some w1: Workstation |(w in end or w in begin or w in w1.succ) and (w not in w.succ) and end in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ )\n\t(all w:Workstation | w not in end implies one w.succ)\n\t(all w:Workstation,b:begin | w in b.*(succ))\n\t\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation |some w1: Workstation |(w in end or w in begin or w in w1.succ) and (w not in w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | x != begin and x != end implies \n  \t\t\t\t\t\t\tx in begin.^succ and end in x.^succ\n   begin != end\n \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | x != begin and x != end implies \n  \t\t\t\t\t\t\tx in begin.^succ and end in x.^succ\n \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tall w: Workstation | w not in w.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | (w = begin or w = end or (w in begin.^succ and w in ^succ.end)) and w not in w.^succ and lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tno (end.succ)\n    no ( succ.begin )\n  \t\n  \tall w : Workstation - begin| begin in (*(succ).w)\n  \n  \tall w : Workstation - end| end in w.*(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \t(ws in begin and no ws.succ implies ws in end) or (one ws & begin and end in (ws.^succ - ws)))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation |some w2: Workstation | w2 not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  one w : Workstation | begin in w\n  one w : Workstation | end in w and no w.succ\n  all w : Workstation | (one begin&w) iff no end&w\n  all w : Workstation-begin-end | one succ.w and one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | one su:ws.succ | ws in begin implies su in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: (Workstation-begin-end) | ws not in (ws.^succ) and some(succ.ws) and end in (ws.*succ)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end implies no(w.succ)\n  all w : Workstation | w in begin implies some(w.succ)\n  all w : Workstation | (w not in end) and ( w not in begin) implies one(w.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \t//Begin is the first\n  \tbegin not in Workstation.^succ\n  \t//Everyone is after begin\n  \t//(Workstation-begin) in begin.^succ\n  \t\n  \t//No loops\n  \tall w:Workstation | w not in w.^succ && lone w.succ\n  \t//End is the last\n  \tno end.succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall c:Component | all parts: c.parts | c.workstation in parts.^workstation.succ and c.workstation not in parts.^workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation|ws in begin+end or ws in begin.^succ and ws not in end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end iff one Workstation\n\tall w : Workstation | not begin in w.^succ\n\tall w : Workstation | end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w: Workstation - end.succ | w in w.succ\n    all w: Workstation - begin.succ | w not in w.succ\n    some w: Workstation | w in begin.succ and w in end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | x not in x.^succ\n  \tall x: Workstation | (x != begin and x != end implies \n  \t\t\t\t\t\t\tx in begin.^succ and end in x.^succ)\n \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wt : Workstation | one wts : Workstation | wt not in wts.^succ and wt!=wts\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ) and (all w : Workstation | w not in w.succ) and (no end.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wt : Workstation | one wts : Workstation | wt in wts.^succ and wt!=wts\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall disj w1, w2: Workstation | w1 in w2.^succ or w2 in w1.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t/* succ in Workstation one -> lone Workstation \n    #Workstation > 1 => begin != end and begin.^succ = end and no end.succ\n  \telse (one Workstation => begin = end and no succ)\n\t*/\n  \t\n  \t#Workstation = 1 => begin = end and no succ\n  \telse\n  \n  \t(succ in (Workstation - end) one -> one (Workstation - begin)\n        and \n     end in begin.^succ\n  \t)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(begin.succ = end) and all ws: Workstation - end |\n        one ws.succ and ws.succ in Workstation - begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ and (begin in w implies end in w.*succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  //\tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome w: Workstation  | begin not in succ.w\n    some wo: Workstation | begin in *succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  some w : Workstation | (no succ.w and begin in w) or (no w.succ and end in w)  \n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - end |\n        (w in begin.~succ or one w.succ)\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | one w.succ and one w.~succ\n    no begin.succ and no end.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all disj ws1, ws2 : Workstation | ws1.succ != ws2.succ\n  all ws : Workstation | ws.succ != ws\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin.succ = end \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin = end\n  all ws : Workstation | ws.succ != ws and ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ != begin\n  all ws : Workstation | ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end implies one Workstation or begin.^(succ) = end\n  all ws : Workstation | ws.succ != ws\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  (all ws : Workstation | ws = begin or ws in begin.^(succ)) and (begin.^(succ) = end or begin = end) and begin.succ != begin and end.succ != begin\n}",
                    "{\n\tall w : Workstation | not w->w in succ\n\n\tall w:Workstation | w in begin implies (some w2:Workstation | w->w2 in succ)   //o begin tem um succ\n\tall w1,w2,w3:Workstation | (w1 in begin and w1->w2 in succ and w1->w3 in succ) implies (w2=w3) //o begin tem apenas um succ\n\n\tall w:Workstation | w in end implies (some w2:Workstation | w2->w in succ)  //o end e succ de alguem\n\tall w1,w2,w3:Workstation | (w1 in end and w2->w1 in succ and w3->w1 in succ) implies (w2=w3) //apenas alguem tem o end como succ\n\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall b : begin, w : Workstation | not b->w in succ  //begin nao e succ de nada\n\tall e : end, w : Workstation | not w->e in succ //end nao tem succ\n\n\tall b : begin, w : Workstation | w!=b implies w in ^succ.b //todo workstation esta na linha de succ do begin\n\tall e : end, w : Workstation | w!=e implies e in ^succ.w //o end esta na linha de succ de qualquer workstation\n\n\tall w : Workstation | not w in ^succ.w  //nao existem ciclos de sucessores\n\n\tall x,y,z: Workstation  | (x->y in succ and x->z in succ) implies y=z //nada tem dois succs\n\tall x,y,z: Workstation  | (y->x in succ and z->x in succ) implies y=z //nada \u00e9 succ de duas coisas\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no begin.succ \n    no end.workers \n\n    // Every workstation except for the begin and end must have one predecessor and one successor\n    all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no end.succ\n  begin = end or \n    all workstation: Workstation | \n        one workstation.succ and workstation !in workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.succ\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n\n  \tall b : begin |\n  \t\tend in b.*succ and\n  \t\tno succ.b and no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | end in w.^succ or begin in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin and wstation not in end implies end in wstation.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no begin & end and\n  one begin and one end and\n    (all w: Workstation - begin - end | one w.succ) and\n    (all w: Workstation - begin - end | one w.~succ) and\n    no w: Workstation | w in w.^succ and\n    begin.^succ = Workstation - begin - end and\n    end.~^succ = Workstation - begin - end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | w in begin.*succ + end.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \n  // Nenhuma esta\u00e7\u00e3o deve ser sucessora de si mesma direta ou indiretamente\n    no w: Workstation | w in w.^succ\n    \n    // Come\u00e7ando em `begin`, deve haver um caminho que termina em `end` que cobre todas as esta\u00e7\u00f5es\n    all w: Workstation | w in begin.*succ + end.~succ\n    \n    // Apenas `end` n\u00e3o tem sucessores\n    no end.succ\n    \n    // Apenas `begin` n\u00e3o tem predecessores\n    no begin.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w:Workstation | no succ.begin\n  \tall e:end | no e.succ\n  \tone succ.end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies one succ.end and end in begin.^succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,wb : Workstation | (wb in begin and w!=wb) implies w in wb.^(succ)\n  all w : Workstation | w not in w.^(succ)\n  all w : Workstation | w not in end implies lone w.succ\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | \n  \tall wStart: (Workstation & begin) |\n  \tsome wEnd: (Workstation & end) | \n  \t\twStart not in w.succ and wEnd in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | \n \t\twStart not in w.^succ\n  \tall wStart: (Workstation & begin) - end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n  \tall w: Workstation | no w.succ implies w in begin\n  \tsome w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | begin in succ.w\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | begin in succ.w\n  \t\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | ( w = begin implies (some w1:Workstation | w->w1 in succ)) and (w = end implies (some w2: Workstation | w2->w in succ))\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w -> w not in succ\n  \n    all w : Workstation | (one w1:Workstation | begin->w1 in succ) and (one w2: Workstation | w2->end in succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  succ in begin -> end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  Workstation = begin.*succ + end\n  \n  no end.succ\n  \n  all w: Workstation | lone w.succ and lone w.~succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno (begin & Workstation.succ)\n  \tall w : Workstation | one (w.succ & end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend in Workstation.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies ws1 not in ws1.succ and ws2 not in ws2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno begin.~succ\n  \tno end.succ\n  \tno s: Workstation | s in s.^succ\n  \t//all s: Workstation - end | one s.succ\n  \tall s: Workstation - begin | one s.~succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ\n  all wk : Workstation | wk in begin implies some ( wk.^(succ.succ) & end ) or wk in begin and wk in end \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ\n  all wk : Workstation | wk in begin implies some ( wk.^(succ.succ) & end )\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ and ( wk in begin implies wk not in end ) \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ and ( wk in begin implies wk not in end ) \n  all wk : Workstation | wk in begin implies some ( wk.^(succ.succ) & end )\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - begin | ws in begin.^succ\n\tall ws: Workstation - end | end in ws.^succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n  \tbegin in *succ.end\n  \tall s: Workstation | s not in s.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | no succ.begin and no end.succ and no (w & w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w1, w2: Workstation | w1 in w2.^succ or w2 in w1.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | no w.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | no w.succ\n\tone w : Workstation | no w2 : Workstation | w in w2.succ\n  \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | let succ = w.^succ | Workstation in w+succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | #w.succ = 1 implies w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (#w.succ + #w.~succ = 1 or #w.succ + #w.~succ = 2) and \t Workstation in w.*succ + w.~*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | #w.succ = 1 and w not in w.^succ and Workstation in \t   w.^succ + w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no succ.begin\n  no end.succ\n  some Workstation.succ\n  all e: begin | end in e.*(succ)\n  \n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | some w.succ implies (w not in begin and w not in end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w not in begin and w not in end) implies one w.succ\n  all w: Workstation | w not in w.^(succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | ( w!= end implies #w.succ = 1) and (w != begin implies w in begin.^succ) and w.succ != w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| ws in begin.*succ and ws not in end.^succ or ws in begin&end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.succ.^succ\n  \tend.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end or\n\tall ws: Workstation | (#ws.succ = 1 iff ws not in end) and ws not in ws.^succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation-end | one w.succ\n  \tall w : Workstation | w not in w.succ\n  \tall b : begin, w : Workstation | b not in w.succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | (ws not in end implies #ws.succ=1) and ws not in ws.succ and\n  \t\t\t\t\t\t\t(ws not in begin implies ws in Workstation.succ)\n  \tone ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tbegin.^succ = Workstation - begin\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation-begin in begin.^succ\n    //all wo : Workstation | (wo.succ != none => wo not in wo.^succ and #wo.succ = 1)\n  \t//all wo : Workstation | wo.succ = none => wo = end\n  \tall wo : Workstation-begin-end | one wo.succ and wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.*succ = end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend = begin.^succ and begin != end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | ws.succ != ws) and end = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w: Workstation {\n      no succ.w\n      all k: Workstation - w | one k.succ\n    }   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone first: Workstation, latest: Workstation {\n      no succ.first\n      no latest.succ\n      all k: Workstation - first - latest | one k.succ\n    }   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone first: Workstation, latest: Workstation {\n      no succ.first\n      no latest.succ\n      all k: Workstation - first | one k.succ\n    }   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n    succ in Workstation -> lone Workstation\n    one w : Workstation | no w.succ\n//    all w : Workstation | not w in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ and end != begin\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(succ in (Workstation lone -> lone Workstation)) and (end in begin.^succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall disj w1, w2: Workstation | w1 not in w1.^succ and (w1 in w2.^succ or w2 in w1.^succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc in (Workstation lone -> lone Workstation)\n\tand (all w: Workstation | w  in begin.*succ) // initial element\n\t//and ( no end.^succ ) // final element\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall disj a, b: Workstation | a.succ = b implies a not in b.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n//  \tall ws: Workstation | ws.succ != ws\n  \tall ws: Workstation | ws not in end implies one ws.succ\n  \tall ws: Workstation | ws in begin implies ws.*succ = Workstation\n  \tall disj a, b: Workstation | a.succ = b implies a not in b.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | no (begin & end) implies one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | lone w.succ implies one (begin & end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | lone w.succ iff no (begin & end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | one w.succ implies no (begin & end)\n  all w: Workstation| no w.succ implies one w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | one w.succ implies one (begin & end)\n  all w: Workstation| no w.succ implies one w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | one w.succ implies some (begin & end)\n  all w: Workstation| one (begin & end) implies no w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | some (begin & end) implies some w.succ\n  //all w: Workstation| one (begin & end) implies no w.succ\n  //each workstation only has one or no succ\n  //all w: Workstation | lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//all w: Workstation | no (begin & end) implies lone w.succ\n  all w: Workstation | some (begin & end) implies lone w.succ and w not in w.^succ\n  //all w: Workstation| one (begin & end) implies no w.succ\n  //each workstation only has one or no succ\n  //all w: Workstation | lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tone e: end, b: begin | ((e = b) and (#Workstation > 1)) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tbegin != end\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^succ\n  \t//all w: begin.^succ | begin not in w.^succ and w not in w.^succ and end in w.^succ\n  \tall w: begin.^succ | w.succ not in w.succ.^succ\n  \tno end.succ\n  \tall w: Workstation | lone w.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t//all w: Workstation | w not in w.^succ\n  \t//all w: begin.^succ | begin not in w.^succ and w not in w.^succ and end in w.^succ\n  \tall w: begin.^succ | w.succ not in w.succ.^succ\n  \tno end.succ\n  \tall w: Workstation - end | one w.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - end | one w.succ and w not in w.^succ\n  \tall w: Workstation - begin | one succ.w\n  \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | one begin.succ & w and one w.^succ & end\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tall w : Workstation | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tall w : Workstation-end | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin != end implies begin in begin.^succ\n  \tall w : Workstation-end | one w.succ\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin != end implies begin in begin.^succ\n  \tbegin = end implies no begin.succ\n  \tall w : Workstation-end | one w.succ\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ) and (no end.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ) and (all w : Workstation | w not in w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ) and not(w in w.^succ) and lone(succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ) and lone(succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ) and lone(succ.w) and not(w in w.succ) and not(w in succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ + workstation.w) and lone(succ.w + workstation.w) and not(w in w.succ) and not(w in succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation | one w.succ and begin.^succ = Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation-end | one w.succ \n\tbegin != end implies begin.^succ = Workstation - begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ + workstation.w) and lone(succ.w + workstation.w) and not(w in w.succ) and not(w in succ.w) and w in begin implies not w in end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ + workstation.w) and lone(succ.w + workstation.w) and not(w in w.succ) and not(w in succ.w) and (w in begin implies not w in end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation-end | one w.succ \n  \tbegin != end implies no end.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | one(begin) and one(end) and ((w in begin) implies lone(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies lone(succ.w)) and (not(w in w.succ) and not(w in succ.w))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | (one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and (not(w in w.succ) and not(w in succ.w))) or one(Workstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (one disj c1, c2:Workstation | (c1 in begin) and (c2 in end) and (c1.^succ = Workstation - c1) and no(c2.succ)) or (one c1:Workstation | (c1 in begin) and (c1 in end) and no(c1.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and b not in e.^succ implies e in m.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and b not in e.^succ implies e in m.^succ and b not in m.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and b not in e.^succ implies e in m.^succ and b not in m.^succ\n  \tall w : Workstation | w not in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and e in m.^succ implies e in b.^succ\n  \tall w : Workstation | w not in w.succ\n    all b : begin, e : end | b not in e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and e in m.^succ implies e in b.^succ\n  \tall w : Workstation | w not in w.succ\n    all w : Workstation | w in begin implies w not in end\n    all b : begin, e : end | b not in e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and e in m.^succ implies e in b.^succ\n  \tall w : Workstation | w not in w.succ\n    all w : Workstation | w in begin implies w not in end\n    all b : begin, e : end | b not in e.succ\n  \tall e : end | no e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall W : Workstation | some (W.succ) implies one (W.succ) and no (W.succ & W)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall W : Workstation | some (W.succ) implies one (W.succ) and no (W.succ & W &begin)\n  \tand (one begin.succ) and (no end.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - (begin & end)| one (W.succ) and no (W.succ & W)\n  \tand (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\nall W : Workstation - (begin & end)| one (W.succ) and no (W.succ & W) and no (W.succ & begin) and (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\nall W : Workstation - (begin & end)| no(W.succ & W) and no(W.succ & begin) and (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\tand no(end.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\tand end != begin\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\tand end != begin and no(end.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W and no(end.succ) and\n   no(begin & W.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n // all w : Workstation | (w in begin and w in end and none = w.succ) or ((w in begin.^succ or w in begin) and w not in w.^succ and (end in w.^succ or w in end) and (one begin.^succ & w or w in begin))\n\t// all w : start | (one w.^succ & end and w not in w.^succ)\n  all w : Workstation | ((one w.succ => end in w.^succ) or w = end) and (w = begin or w in begin.^succ)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(begin = end or one (begin.^succ :> end)) and begin not in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(begin = end or no(Workstation - begin.^succ :> end)) and begin not in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation =  (begin <: begin.*succ :> end + begin + end) and Workstation.^succ != Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation =  (begin <: begin.*succ :> end + begin + end) and Workstation.^succ != Workstation and no end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation.succ = Workstation - begin\n  \tsucc.Workstation = Workstation - end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//(one w:Workstation | w in begin) and (one w:Workstation | w in end) and (all w:Workstation | some succ.w )\n  \t//all b:begin | all w : Workstation | w in b.*(succ)\n  \t//all w:Workstation | w not in end implies one w.succ\n  \tall w:Workstation | (w not in begin and w not in end) implies w in succ.w  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | (w in end or w in begin) and (w not in w.succ) and (end in begin.succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | no b.succ and b in end) or (all w:Workstation | w not in end implies one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ ) or (all w:Workstation | w not in end implies one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ ) and (all w:Workstation | w not in end implies one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ )\n\t(all w:Workstation | w not in end iff one w.succ)\n\t(all w:Workstation,b:begin | w in b.*(succ))\n\t\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w in end) or (w in begin) or \n(w in Workstation.succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | x != end implies end in x.^succ\n  \tno succ.begin \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tend in Workstation.succ\n  \tall w: Workstation | w not in w.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tall w: Workstation | w not in (w.^succ - end)\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tsome w: Workstation | w.succ = end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | w in begin or w in end or (w in begin.^succ and w in ^succ.end and w not in w.^succ and one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    (all w : Workstation - begin - end | w in begin.^succ and w in ^succ.end and some w.succ) and\n  \t(all b : begin | no succ.b and lone b.succ) and\n  \t(all e : end   | no e.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \tws not in ws.succ and\n  \tone ws & begin iff one end & ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \t(ws in begin and no ws.succ implies ws in end) and (ws in begin and one ws.succ implies end in (ws.^succ - ws)))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \t(ws in begin and no ws.succ implies ws in end) and (ws in begin and one ws.succ and ws not in ws.succ implies end in (ws.^succ - ws)))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one Workstation or one begin.succ and one succ.end and (all w: Workstation - begin - end | one w.succ and one succ.w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tone Workstation\n  \t\t=> no succ\n  \telse (one begin.succ and one succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tone Workstation\n  \t\t=> no succ\n  \telse (\n      \t(all w: Workstation | lone w.succ and w not in w.succ)\n//    \tand (all w: Workstation - end | one w.succ)\n//  \t\tand (all w: Workstation - begin | one succ.w)\n\t\tand (no end.succ) and (no succ.begin)\n    )\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation |some w2: Workstation | w2 not in w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: (Workstation+begin+end) | one begin.*succ & w\n  \tend in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall disj w1, w2: Workstation | w1 != w2 and w1 in begin.*(succ) and w2 in begin.*(succ) implies w1 in w2.*(succ) or w2 in w1.*(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | w = begin or lone w.succ\n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: (Workstation-begin-end) | ws not in (ws.^succ) and some(succ.ws)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: (Workstation-begin-end) | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ)   \n  \t(begin != end) implies some(succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tall ws: (Workstation-begin-end) | some(ws.succ)\n  \tno(succ.begin) and no(end.succ)   \n  \t(begin != end) implies some(succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end implies no(w.succ)\n  all w1 : Workstation | w1 in begin implies one(w1.succ)\n  all w2 : Workstation | (w2 not in end) and (w2 not in begin) implies one(w2.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end implies no(w.succ)\n  all w1 : Workstation , wb: begin | w1 in wb.*(succ)\n  all w2 : Workstation | (w2 not in end) and (w2 not in begin) implies one(w2.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation - begin | w in begin.^succ && one begin.succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall c:Component | all parts: c.parts | c.workstation in parts.workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| ws in begin or ws in begin.^succ & end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | not begin in w.^succ\n\tall w : Workstation | begin != end implies end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies one Workstation\n\tall w : Workstation | not begin in w.^succ\n\tall w : Workstation | begin != end implies end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| (ws in begin.^succ and ws not in end.^succ) or (ws in begin&end and ws not in ws.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| (ws in begin.^succ and ws not in end.^succ) or (ws in begin&end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n    begin != end iff all w : Workstation | w != begin and w != end implies w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end iff one Workstation\n\tbegin != end implies all w : Workstation - {begin + end} | w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w: Workstation | w in w.succ and (w not in end.succ implies w not in begin.succ)\n}",
                    "{\n  // Workstations form a single line from begin to end\n  all ws : Workstation | (ws = begin and ws.succ = end)\n  or\n  (ws = end and ws.succ = begin)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all ws:Workstation | one b:begin | one e :end | ws in b.succ or e in ws.succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall disj w1, w2 : Workstation | w1 in begin.succ.*succ and w2 in end.succ.*succ implies w1 in w2.succ.*succ or w2 in w1.succ.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies one Workstation \n\t\n  \tbegin not in Workstation.succ  \n  \tend in Workstation.succ\t\n  \t\n  \tno end.succ\n \t\t\n  \tall w : Workstation-end | one w.succ and w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies one Workstation\n  \tbegin != end implies {\n      \tall w : Workstation-end-begin | one w.succ \n  \t\tall w : Workstation-end-begin | w not in w.succ \n    \tall w : Workstation-end-begin | one s : Workstation | s.succ = w\n    }\n  \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies {\n      \tone Workstation\n      \tno end.succ\n  \t}\n      \n  \tbegin != end implies {\n      \tone begin.succ\n      \tno end.succ\n      \t\n      \tall w : Workstation | w not in w.^succ  \n    }\n  \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end or (begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end or (one Workstation and begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    #Workstation > 1 => begin != end and begin.^succ = end \n  \telse (one Workstation => begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    #Workstation > 1 => begin != end and begin.^succ = end and no end.succ\n  \telse (one Workstation => begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t/* succ in Workstation one -> lone Workstation \n    #Workstation > 1 => begin != end and begin.^succ = end and no end.succ\n  \telse (one Workstation => begin = end and no succ)\n\t*/\n  \t#Workstation > 1 => ^succ in begin one -> one end\n  \telse (one Workstation => begin = end and no succ)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno begin & end\n    all w : Workstation | lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    lone begin.succ and no end.succ\n    all w : Workstation | lone w.succ and w not in w.^succ\n    //Workstation.succ = Workstation - begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | one b: begin, e: end | e in ws.^succ and ws in b.^succ or ws = b and ws = e\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws in begin.^succ and end in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws in begin.^succ and end in ws.^succ and one ws2 : Workstation | ws.succ = ws2\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tlet line = begin.*(succ) & Workstation\n    {\n        all ws: Workstation | ws in line and (ws != ws.succ) \n        one last: line | last.succ = end and last not in last.^succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws in begin => one ws.succ or ws in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | begin in w implies w not in w.succ and end in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome w : Workstation | begin in w iff end in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.succ and one w.succ and (begin in w implies end in w.*succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome w : Workstation | w not in w.^succ and lone w.succ and (begin in w and end in w.*succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ\n  \tsome w : Workstation | w.succ = Workstation-w and begin in w and end in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ\n  \tsome w : Workstation | w.^succ = Workstation-w and begin in w and end in w.^succ\n  \tsome w : Workstation | end in w implies no w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome wo: Workstation | begin in succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome wo: Workstation | begin in *succ.wo and end in wo.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome wo: Workstation | begin in *succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  //\tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome w: Workstation  | begin not in *succ.w\n    some wo: Workstation | begin in *succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome w: Workstation  | begin not in succ.w\n    some wo: Workstation | begin in wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tall w: Workstation  | begin not in succ.w\n    some wo: Workstation | begin in wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  all w : Workstation | (no succ.w and begin in w) or (no w.succ and end in w) or (begin not in w and end not in w)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  some w : Workstation | (no succ.w and begin in w) or (no w.succ and end in w) or (begin not in w and end not in w)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  all w : Workstation | begin in w implies no succ.w and end in w implies no w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  all w : Workstation | begin in w implies no succ.w or end in w implies no w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | lone w.succ and lone succ.w// and w+w.^succ+^succ.w = Workstation\n\tall w : Workstation | begin in w implies no succ.w \n\tall w : Workstation | end in w implies no w.succ \n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | lone w.~succ and lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n      let line = Workstation - begin - end | all w: line | one w.succ and w not in w.succ\n\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no ws: Workstation | ws not in begin.*succ || ws not in end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - end | some ws.succ\n    all ws: Workstation - begin | lone ws.succ\n    end not in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tall w : Workstation - end | some s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tno w : Workstation | w in end.succ\n  \tall w : Workstation - end | some s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tno w : Workstation | w in end.succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tno w : Workstation | w in end.succ\n  \tno w : Workstation | begin in w.succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - begin | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | one s : Workstation | s in w.succ\n  \tall w : Workstation - begin | one s : Workstation | w in s.succ\n  \tbegin = end => no s : Workstation | s in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n  \tno end.succ\n  \tall w: Workstation | w.succ != w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc in Workstation lone -> lone Workstation\n\tend in begin.*succ\n  \tno end.succ\n  \tall w: Workstation | w.succ != w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc in Workstation lone -> lone Workstation\n\tend in begin.*succ\n  \tno succ.begin\n  \tno end.succ\n  \tall w: Workstation | w.succ != w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all disj ws1, ws2 : Workstation | ws1.succ != ws2.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  begin != end and begin + begin.^succ = Workstation and end.succ = none\n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  begin + begin.^succ = Workstation\n  all ws : Workstation | lone ws.succ and ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws = begin or ws = end\n\tall ws: Workstation | ws != end implies one ws.succ\n  \tall ws: Workstation | ws != begin implies no ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies one ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | ws != begin or ws != end implies (some ws2: Workstation | ws in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | ws = begin and ws = end implies one Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | some ws2: Workstation | ws in ws2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | ws != begin and ws != end implies ( some ws2: Workstation | ws in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws not in ws.succ\n  \tall ws: Workstation | ws != begin and ws != end implies ( some ws2: Workstation | ws in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin.succ = end or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ.^(succ) = end  or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ != begin\n  begin.^(succ) = end or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ != begin\n  (begin.^(succ) = end and no (Workstation - begin.^(succ))) or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin = end or all ws : Workstation | ws.succ != ws and ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (end in begin.^(succ) or begin = end) and begin.succ != begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end implies one Workstation or begin.^(succ) = end\n  all ws : Workstation | ws.succ != ws and ws in (begin + begin.^(succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (begin.^(succ) = end and no end.succ) or (begin = end)\n\n  all ws : Workstation | ws in (begin + begin.^(succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  (all ws : Workstation | ws = begin or ws in begin.^(succ)) and begin.^(succ) = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  (all ws : Workstation | ws = begin or ws in begin.^(succ)) and (begin.^(succ) = end or begin = end)\n}",
                    "{\n\tall w:Workstation | w in begin implies (some w2:Workstation | w->w2 in succ)   //o begin tem um succ\n\tall w1,w2,w3:Workstation | (w1 in begin and w1->w2 in succ and w1->w3 in succ) implies (w2=w3) //o begin tem apenas um succ\n\n\tall w:Workstation | w in end implies (some w2:Workstation | w2->w in succ)  //o end e succ de alguem\n\tall w1,w2,w3:Workstation | (w1 in end and w2->w1 in succ and w3->w1 in succ) implies (w2=w3) //apenas alguem tem o end como succ\n\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\n}",
                    "{\n\tsome w1,w2 : Workstation | w1 in begin and w2 in end  //existe um begin e um end\n\tall w1,w2 : Workstation | (w1 in begin and w2 in begin) implies (w1=w2) //so existe um begin\n\tall w1,w2 : Workstation | (w1 in end and w2 in end) implies (w1=w2) //so existe um end\n\n\tall w : Workstation | not w->w in succ  // nada \u00e9 succ de ele pr\u00f3prio\n\tall w1,w2:Workstation | (w1 in begin and w2!=w1) implies (not w2->w1 in succ) //ninguem tem o begin como succ\n\tall w1,w2:Workstation| (w2 in end and w1!=w2) implies (not w2->w1 in succ) //o end nao tem ninguem como succ\n\n\t//se algo n\u00e3o \u00e9 begin ou end, entao \u00e9 succ de alguem e tem alguem como succ\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\tall w1,w2,w3:Workstation | (w1->w2 in succ and w1->w3 in succ) implies (w2=w3)  // cada elem tem apenas um succ\n\tall w1,w2,w3:Workstation | (w2->w1 in succ and w3->w1 in succ) implies (w2=w3)  // cada elem e succ apenas de algum ele  \n\n}",
                    "{\n\tsome w1,w2 : Workstation | w1 in begin and w2 in end  //existe um begin e um end\n\tall w1,w2 : Workstation | (w1 in begin and w2 in begin) implies (w1=w2) //so existe um begin\n\tall w1,w2 : Workstation | (w1 in end and w2 in end) implies (w1=w2) //so existe um end\n\n\tall w : Workstation | not w->w in succ  // nada \u00e9 succ de ele pr\u00f3prio\n\tall w1,w2:Workstation | (w1 in begin and w2!=w1) implies (not w2->w1 in succ) //ninguem tem o begin como succ\n\tall w1,w2:Workstation| (w2 in end and w1!=w2) implies (not w2->w1 in succ) //o end nao tem ninguem como succ\n\n\t//se algo n\u00e3o \u00e9 begin ou end, entao \u00e9 succ de alguem e tem alguem como succ\n\t//all w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\n\tall x:Workstation | some y,z:Workstation | (not x in begin and not x in end and y!=z and y!=x and z!=x) implies (y->x in succ and x->z in succ) \t\n\n\tall w1,w2,w3:Workstation | (w1->w2 in succ and w1->w3 in succ) implies (w2=w3)  // cada elem tem apenas um succ\n\tall w1,w2,w3:Workstation | (w2->w1 in succ and w3->w1 in succ) implies (w2=w3)  // cada elem e succ apenas de algum elem\n\n\t//se apenas existe begin e end, entao o end e succ do being ()\n\tall w1,w2:Workstation | (w1!=w2 and ((w1 in begin and w2 in end) or (w1 in end and w2 in begin))) implies ((w1->w2 in succ)or(w2->w1 in succ)) \n\n}",
                    "{\n\tsome w1,w2 : Workstation | w1 in begin and w2 in end  //existe um begin e um end\n\tall w1,w2 : Workstation | (w1 in begin and w2 in begin) implies (w1=w2) //so existe um begin\n\tall w1,w2 : Workstation | (w1 in end and w2 in end) implies (w1=w2) //so existe um end\n\n\tall w : Workstation | not w->w in succ  // nada \u00e9 succ de ele pr\u00f3prio\n\tall w1,w2:Workstation | (w1 in begin and w2!=w1) implies (not w2->w1 in succ) //ninguem tem o begin como succ\n\tall w1,w2:Workstation| (w2 in end and w1!=w2) implies (not w2->w1 in succ) //o end nao tem ninguem como succ\n\n\t//se algo n\u00e3o \u00e9 begin ou end, entao \u00e9 succ de alguem e tem alguem como succ\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation |w1->w2 in succ and w2->w3 in succ)\t\n\n\tall w1,w2,w3:Workstation | (w1->w2 in succ and w1->w3 in succ) implies (w2=w3)  // cada elem tem apenas um succ\n\tall w1,w2,w3:Workstation | (w2->w1 in succ and w3->w1 in succ) implies (w2=w3)  // cada elem e succ apenas de algum elem\n\n\t//se apenas existe begin e end, entao o end e succ do being ()\n\tall w1,w2:Workstation | (w1!=w2 and ((w1 in begin and w2 in end) or (w1 in end and w2 in begin))) implies ((w1->w2 in succ)or(w2->w1 in succ)) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n//nada \u00e9 succ de duas coisas\n  \tall b:begin,e:end| b!=e implies (e in ^succ.b)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n//nada \u00e9 succ de duas coisas\n  \tall b:begin,e:end| b!=e implies (e in ^succ.b)\n  \n  all w : Workstation | not w in ^succ.w  //nao existem ciclos de sucessores\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n//nada \u00e9 succ de duas coisas\n  \tall b:begin,e:end| b!=e implies (e in ^succ.b)\n  \n  all w : Workstation | not w in ^succ.w  //nao existem ciclos de sucessores\n  \n \tall b : begin, w : Workstation | not w->b in succ  //begin nao e succ de nada\n\tall e : end, w : Workstation | not e->w in succ //end nao tem succ\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | one w'.succ & Workstation\n    all w : Workstation - begin | one w'.succ & w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w = end) or (some w.succ)\n    all w: Workstation | (w = begin) or (some w1: Workstation | w in w1.succ)\n    no w: Workstation | w in w.succ\n\n}",
                    "{\n    // All workstations are connected in a single line between begin and end\n    all w : Workstation | \n        (w in begin.succ implies one w.succ) and \n        (w in end.succ implies no w.succ) \n}",
                    "{\n  // Ensure the workstations form a single line between begin and end\n\n  // 1. The `begin` workstation has no successors\n  no w: Workstation | w in begin.succ\n\n  // 2. The `end` workstation has no predecessors\n  no w: Workstation | end in w.succ\n\n  // 3. Each workstation (except begin and end) has exactly one predecessor\n  all w: Workstation - begin - end |\n    one p: Workstation | p in w.succ\n\n  // 4. Each workstation (except begin and end) has exactly one successor\n  all w: Workstation - begin - end |\n    one s: Workstation | w in s.succ\n\n  // 5. Ensure there is a path from begin to end by using a total ordering\n  // Using a helper predicate to check connectivity\n  all w1, w2: Workstation | \n    (w1 in w2.succ) implies (w1 != begin and w1 != end and w2 != begin and w2 != end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = begin or w in begin.^succ) and (w = end or end in w.^succ) and lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | some w.succ implies some begin <: *succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin | some w.succ \n  \tall w : Workstation-end | some succ.w \n  \t//some begin <: ^succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin | some w.succ and no succ.w\n  \tall w : Workstation-end | some succ.w and no w.succ\n  \t//some begin <: ^succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: begin | lone w2: Workstation | w2 in ws.succ\n  \n  \tall ws: end | no w2: Workstation | w2 in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - begin - end | one w.succ and one w.~succ and w in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno begin.~succ and no end.succ\n  \tall w: Workstation - end | one w.succ and one w.~succ\n    all w: Workstation - begin | one w.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - begin - end | one w.succ and one w.~succ\n  \tone begin.succ and no begin.~succ \n  \tone end.~succ and no end.succ \n  \t//Workstation = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n  \tno succ.begin\n    begin.succ = end or all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n  \tno succ.begin\n    begin.succ in end or all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n  \tno succ.begin\n    begin.succ in end or all workstation: Workstation - begin - end | \n        one p: Workstation | p.succ = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end or \n    all workstation: Workstation | \n        one workstation.succ and workstation !in workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no end.succ\n  no succ.begin\n  begin = end or \n    all workstation: Workstation | \n        one workstation.succ and workstation !in workstation.succ\n}",
                    "{\n\tall b : begin | b.~succ = Workstation\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.succ\n\n  \tall b : begin |\n  \t\tend in b.*succ and\n  \t\tno succ.b and no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tno succ.begin\n  \n\tno end.succ\n  \n  \tall w : Workstation | w not in w.succ\n  \t\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | end in w.*succ or begin in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, e: end | {\n      w not in w.succ\n      e in w.^succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.^succ\n      b not in e.succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.*succ\n      b not in e.succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.*succ\n      b not in w.~succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.*succ\n      b not in b.~succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = end or some w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.succ\n  \n  \tall w : Workstation | w in begin.*succ\n  \n  \tall w : Workstation - end | one w.succ\n  \n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w = end or w.^succ in w.^succ.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin implies end in wstation.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tone wstation: Workstation | wstation not in wstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n  \tall wstation: Workstation | no wstation.succ implies wstation in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n  \tall wstation: Workstation | no wstation.succ implies wstation in end\n  \tall wstation: Workstation | some wstation.succ and no succ.wstation\n  \t\timplies wstation in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  let ws = Workstation {\n        some begin and some end and\n        // begin and end are unique\n        no (begin & end) and\n        // all workstations are reachable from begin or can reach end\n        ws = begin.^succ + end.~^succ and\n        // no cycles\n        no w: ws | w in w.^succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome succ and\n    no w: Workstation | w in w.^succ and\n    begin.^succ = Workstation - begin and\n    end.~^succ = Workstation - end and\n    (all w: Workstation - begin - end | one w.succ) and\n    (all w: Workstation - begin - end | one w.~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \n      (begin.succ = end) and\n        (all w: Workstation - end | some w.succ) and\n        (all w: Workstation - begin | some w.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w not in begin and w not in end) implies one w.succ\n  all w: Workstation | w not in w.^(succ)\n  all b: begin | no succ.b\n  all e: end | no e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies one succ.end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies one succ.end and some begin.succ\n  \tend in begin.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies end in begin.^succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tno end.succ\n  \t//end in begin.^succ or end in begin\n  \tall ws:Workstation - begin - end | ws in begin.^succ\n  \tall w: Workstation | w not in w.^succ\n  \tall w: Workstation - end | lone w.succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tno end.succ\n  \tend in begin.^succ or end in begin\n  \t//all ws:Workstation - begin - end | ws in begin.^succ\n  \tall w: Workstation | w not in w.^succ\n  \tall w: Workstation - end | lone w.succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | \n  \tall wStart: (Workstation & begin) |\n  \tsome wEnd: (Workstation & end) | \n  \t\twStart not in w.succ and \n  \t\twStart not in wStart.succ and\n  \t\twStart not in end \n  \t\t\timplies wEnd in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall wStart: (Workstation & begin) | wStart not in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall wStart: (Workstation & begin) | wStart not in wStart.^succ\n  \tall wStart: (Workstation & begin) | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | wStart not in w.^succ\n  \tall wStart: (Workstation & begin) | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | \n \t\twStart not in w.^succ\n  \tall wStart: (Workstation & begin) - end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n  \tall w: Workstation | no w.succ implies w in begin\n  \tone w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation & end | no ws.succ\n  \tall ws: (Workstation & begin) - end | some ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation & end | no ws.succ\n  \tall ws: Workstation | some ws.succ iff ws in begin-end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | some ws.succ iff ws in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | some ws.succ iff ws in begin-end\n  \tone ws: Workstation | ws not in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | workstation not in workstation.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n      all w : Workstation | \n        (w != end implies one w.succ) and \n        (w != begin implies one v : Workstation | w in v.succ)\n\n    // `begin` deve ser alcan\u00e7\u00e1vel por todas as esta\u00e7\u00f5es de trabalho\n    all w : Workstation | w in begin.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n      all w : Workstation | \n        (w != end implies one w.succ) and \n        (w != begin implies one v : Workstation | w in v.succ)\n\n    // `begin` deve ser alcan\u00e7\u00e1vel por todas as esta\u00e7\u00f5es de trabalho\n    all w : Workstation | w = begin implies w in begin.succ\n\n}",
                    "{\n    // Verifica que as esta\u00e7\u00f5es de trabalho formam uma linha \u00fanica entre begin e end\n    all w : Workstation |\n        (w = begin implies (some w1 : Workstation | w -> w1 in succ)) and\n        (w = end implies (some w2 : Workstation | w2 -> w in succ)) and\n        (w != begin and w != end implies (some w1 : Workstation | w -> w1 in succ) and (some w2 : Workstation | w2 -> w in succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | ( w = begin implies (some w1:Workstation | w->w1 in succ)) and (w = end implies (one w2: Workstation | w2->w in succ) ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w -> w not in succ\n  \n    all w : Workstation | ( w = begin implies (one w1:Workstation | w->w1 in succ)) or (w = end implies (one w2: Workstation | w2->w in succ) ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n    // 1. Nenhuma esta\u00e7\u00e3o pode apontar para si mesma\n    all w : Workstation | w -> w not in succ\n\n    // 2. `begin` deve ter exatamente uma esta\u00e7\u00e3o sucessora\n    one w1 : Workstation | begin -> w1 in succ\n\n    // 3. `end` deve ter exatamente uma esta\u00e7\u00e3o predecessora\n    one w2 : Workstation | w2 -> end in succ\n\n    // 4. Todas as esta\u00e7\u00f5es intermedi\u00e1rias devem ter exatamente uma predecessora e uma sucessora\n    all w : Workstation - begin - end |\n        (some w1 : Workstation | w -> w1 in succ) and\n        (some w2 : Workstation | w2 -> w in succ)\n\n    // 5. Todas as esta\u00e7\u00f5es devem ser acess\u00edveis a partir de `begin`\n    all w : Workstation | w in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  Workstation = begin.*succ + end\n  \n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  succ in begin -> end\n  \n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno (end & Workstation.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tall w : (Workstation - begin) | one (w.succ & end)\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend in Workstation.^succ or begin = end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \t(end not in end.^succ and end in Workstation.^succ) or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tbegin.^succ = end\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//begin not in Workstation.^succ\t\t\t\t\t\t\t// No workstation has begin as succ\n  \t//begin.^succ = Workstation - begin\t\t\t\t\t\t// begin has all workstations as succ\n  \tall w : Workstation | w not in w.succ and lone w.succ\t// No workstation has itself as succ and every workstation has only one succ\n  \tend in Workstation.^succ or lone Workstation\t\t\t// end is succ of every workstation or there is only one workstation\n  \tno end.succ\t\t\t\t\t\t\t\t\t\t\t\t// end does not have any workstations as succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t//begin.^succ = Workstation - begin\t\t\t\t\t\t// begin has all workstations as succ\n  \tall w : Workstation | w not in w.succ and lone w.succ\t// No workstation has itself as succ and every workstation has only one succ\n  \tno end.succ\t\t\t\t\t\t\t\t\t\t\t\t// end does not have any workstations as succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin.^succ = Workstation - begin\t\t\t\t\t\t// begin has all workstations as succ\n  \tall w : Workstation | w not in w.succ and lone w.succ\t// No workstation has itself as succ and every workstation has only one succ\n  \t//no end.succ\t\t\t\t\t\t\t\t\t\t\t\t// end does not have any workstations as succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one w2: Workstation - end - begin | w2 in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation, s:ws.succ | begin in s and end in s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | one s:ws.succ | begin in s and end in s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | \n        one ws.succ or ws = end // Each workstation has at most one successor, except `end`\n    \n    // Begin has no predecessor, and all workstations are reachable from `begin`\n    no ws: Workstation | ws in begin.~succ\n\n    // All workstations are reachable from `begin`, and the line ends at `end`\n    all ws: Workstation | ws in begin.*succ\n}",
                    "{\n  all disj ws, ws1: Workstation | ws not in ws.^succ and ws in ws1.succ or ws1 in ws.succ\n\t// The workstations form a single line between begin and end\n\n}",
                    "{\n all ws: Workstation | lone ws1 : Workstation | ws not in ws.^succ and ws1 !=ws and ws1 not in ws1.^succ and ws1 in ws.succ\n\n// The workstations form a single line between begin and end\n\n}",
                    "{\n all disj ws,ws1: Workstation| ws not in ws.^succ and ws1 not in ws1.^succ\n\n// The workstations form a single line between begin and end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies (ws1 not in ws1.succ and ws2 not in (ws2.succ + ws1.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies (ws1 not in (ws1.succ + ws2.succ) and ws2 not in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies (ws1 not in (ws1.succ + ws2.succ) and ws2 not in ws2.succ and ws2 in ws1.succ)\n}",
                    "{\n    // 1. Every workstation except `end` has exactly one successor.\n    all w : Workstation - end | #w.succ = 1\n    \n    // 2. `end` has no successor.\n    no end.succ\n    \n    // 3. The `begin` workstation is reachable from itself through succ, ensuring `begin` starts the line.\n    begin in Workstation.*succ\n    \n    // 4. There is a single path from `begin` to `end`, covering all workstations.\n    all w : Workstation | w in begin.*succ or w = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation, wss: Workstation - ws |\n  \t\tws in begin => ws not in wss.succ\n  \n  \tall ws: Workstation |\n  \t\tws in end => no ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation, wss: Workstation - ws |\n  \t\tws in begin => ws not in wss.succ\n  \n  \tall ws: Workstation |\n  \t\tws in end => no ws.succ\n  \n  \tall ws: Workstation - end |\n  \t\tone ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : Workstation | begin in w + w.~succ\n  \t//all w : Workstation | end in w + w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : begin.^succ | end in w + w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : end.~succ | begin in w + w.~succ\n  \tall w : begin.^succ | end in w + w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ\n  all wk : Workstation | wk in begin iff some ( wk.^(succ.succ) & end )\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall wk : Workstation | wk in begin iff no (wk.~succ)\n\tall wk : Workstation | wk in end iff no wk.succ\n\tall wk : Workstation | wk in begin.*succ\n\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | no (w & w.succ) no succ.begin and no end.succ and some begin.succ and some succ.end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x : begin | no succ.x\n  \tall x :Workstation - end | one x.succ\n  \tall x: end | no x.succ and x not in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x : begin | no succ.x\n  \tall x :Workstation - end | one x.succ\n  \tall x: end | no x.succ\n  \tall x : Workstation | some Workstation -x implies no begin & end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w1 : Workstation | one w2 : Workstation | w1 in w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | no w.succ\n\tsome w : Workstation | no w2 : Workstation | w in w2.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one (w & begin) implies (some (w.succ) and one (w & end)) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w1 : Workstation | all w2 :  Workstation - w1 |  w2 in w1.^succ\n  \tall w : Workstation | #(w.succ) < 2\n  \tone w1 : Workstation | all w2 :  Workstation - w1 |  w1 in w2.^succ\n  \t \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | no (w.succ & begin) and one (w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | #w.succ = 0 implies Workstation in w.*(~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | #w.succ = 0 implies Workstation in w.^(~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | w.~succ = none and Workstation in w.*succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | let succ = w.^succ | Workstation in w+succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | let succ = w.^succ | Workstation in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | #w.succ = 1 implies (w not in w.^succ and Workstation in \t   w.^succ + w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \tall w: Workstation | one b: begin |one e: end | b in w.succ and e in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \tall w: Workstation | one b: begin |one e: end | b in w.*succ and e in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \none Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n\tone Workstation-end.succ \n  \t\n  \tno succ.end\n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no succ.begin\n  no end.succ\n  some Workstation.succ\n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1 : Workstation | some ws2 : Workstation | ws2 in begin implies ws1 in ws2.^(succ)\n  \n  all w : Workstation - end | one w.succ\n  \n  no end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w not in begin) and (w not in end) implies one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w not in begin) and (w not in end) implies one w.succ\n  \tall w: Workstation | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | one b:Workstation | one e:Workstation |\n  \t\tws in b.^succ and e in b.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | one b:begin |\n  \t\tb.^succ & ws.^succ = ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation in begin.^succ\n  \tWorkstation in end.^(~succ)\n  \t\n  \tall ws:Workstation - begin - end | one s:Workstation | one p:Workstation |\n  \t\ts = ws.succ and p = ws.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation in begin.^succ\n  \tWorkstation in end.^(~succ)\n  \t\n  \tall ws:Workstation - end - begin | one s:Workstation | one p:Workstation |\n  \t\ts = ws.succ and p = ws.~succ\n  \n  \tall ws:Workstation | ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation |  #w.succ = 1 and w != begin implies w in begin.*succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation |  w!= end implies #w.succ = 1 and (w != begin implies w in begin.*succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - begin |\n  \t\tws in begin.^(succ) and \n  \t\tWorkstation - begin.^(succ) = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.succ.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.succ.^succ\n  \tend.succ = none\n  \tbegin & end = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws.succ != none iff ws != end\n  \tall disj w1, w2: Workstation | w1.succ != w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws not in ws.^succ and ws.succ != none iff ws != end\n  \tall disj w1, w2: Workstation | w1.succ != w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws not in ws.^succ and (ws.succ != none iff ws != end)\n  \tall disj w1, w2: Workstation | w1.succ != w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#begin.succ = 1\n  \t#end.succ = 0\n\tall ws: Workstation | ws not in ws.^succ and (ws.succ != none iff ws != end)\n  \tall disj w1, w2: Workstation | w1.succ & w2.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | end in ws.*succ and (ws.succ != none iff ws not in end)\n  \tall disj w1, w2: Workstation | w1.succ & w2.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end or\n\tall ws: Workstation | ws.succ != none iff ws not in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | \n  \t\tws not in ws.^succ and\n  \t\tws not in end implies #ws.succ = 1\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | #ws.succ=1 and ws not in ws.succ\n  \tone disj ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.*(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.^(succ)\n  \tbegin.succ != end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.^(succ)\n  \tbegin & end != none\n}",
                    "{\n\t// The workstations form a single line between begin and end\nend in begin.*succ\n  all ws : Workstation | ws != end implies one ws.succ\n  all ws : Workstation | ws != begin implies one pre : Workstation | ws in pre.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n  \tbegin in *succ.end\n  \tall wo : Workstation | wo.succ not = none => begin not = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc not in iden\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc - iden = succ\n  \tWorkstation in begin.*succ\n  \tbegin.succ not = none => end in begin.^succ\n  \tall wo : Workstation | wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall disj wo1, wo2 : Workstation | wo1.succ not = none => wo2 in wo1.^succ and wo1 not in wo1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tend in begin.^succ\n  \tall disj wo1, wo2 : Workstation | wo1.succ not = none => wo2 in wo1.^succ and wo1 not in wo1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not = end => end in begin.^succ\n  \tall disj wo1, wo2 : Workstation | wo1.succ not = none => wo2 in wo1.^succ and wo1 not in wo1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \tend in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \t#Workstation != 1 => end in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    all wo : Workstation | (wo.succ not = none => wo not in wo.^succ) and wo.succ = none => wo = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    all wo : Workstation | (wo.succ != none => wo not in wo.^succ)\n  \tone wo : Workstation | wo.succ = none => wo = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    //all wo : Workstation | (wo.succ != none => wo not in wo.^succ and #wo.succ = 1)\n  \t//all wo : Workstation | wo.succ = none => wo = end\n  \tall wo : Workstation-begin-end | one wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation-begin in begin.^succ\n    //all wo : Workstation | (wo.succ != none => wo not in wo.^succ and #wo.succ = 1)\n  \t//all wo : Workstation | wo.succ = none => wo = end\n  \tall wo : Workstation-end | one wo.succ and wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all b : begin | some succ.b\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ and end.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | w != end implies one w.succ and w != begin implies one succ.w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  ^succ = (Workstation -> Workstation) - (end -> Workstation) - iden\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  *succ = iden + (Workstation -> end) and no end.succ and no succ.begin\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin != end implies end in begin.*succ else no begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | ws.succ != ws) and end = begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | (one ws2 : Workstation | ws.succ = ws2) or ws = end) and no ws : Workstation | ws.succ = begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | (one ws2 : Workstation | ws != ws2 and ws.succ = ws2) or ws = end) and no ws : Workstation | ws.succ = begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t// Only 'begin' has no predecessor\n  no w: Workstation - begin | some w.~succ\n  \n  // Only 'end' has no successor\n  no w: Workstation - end | some w.succ\n\n  // Every workstation (except end) has at most one successor\n  all w: Workstation - end | lone w.succ\n\n  // Every workstation (except begin) has at most one predecessor\n  all w: Workstation - begin | lone w.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  // Every workstation (except end) has at most one successor\n  all w: Workstation - end | lone w.succ\n\n  // Every workstation (except begin) has at most one predecessor\n  all w: Workstation - begin | lone w.~succ\n  \n  all w: Workstation | w not in w.succ\n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2 : Worker | some disj C1 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        workers = WS1->W1 + WS2->W2\n        succ = WS2->WS1 // breaks the line: edge goes from end back to begin, no single forward chain from begin to end\n\n        Worker = W1 + W2\n        Human = W1 + W2\n        no Robot\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        no Dangerous\n\n        parts = C1->M1\n        workstation = C1->WS1\n\n        // Negative: succ points WS2->WS1, so there is no single line from begin (WS1) to end (WS2).\n        // Satisfies others: all workers are Human or Robot (here all Human); each workstation has one worker and each worker belongs to exactly one workstation; each component has exactly one workstation; components have parts and materials have no parts; no human-robot mixing; no component is its own part; no dangerous parts/components used; thus no dangerous component is assembled by humans.\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1, M2 : Material {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        workers = WS1->W1 + WS2->W2 + WS3->W3\n        succ = WS1->WS2 + WS1->WS3 // breaks the line: branching from begin, not a single predecessor/successor chain\n\n        Worker = W1 + W2 + W3\n        Human = W1\n        Robot = W2 + W3\n\n        Product = C1 + C2 + M1 + M2\n        Material = M1 + M2\n        Component = C1 + C2\n        Dangerous = M2 + C2\n\n        parts = C1->M1 + C2->M2\n        workstation = C1->WS1 + C2->WS2 // dangerous component C2 is assembled at robot-only WS2\n\n        // Negative: succ branches at WS1 (two successors), so workstations do not form a single line from begin (WS1) to end (WS3).\n        // Satisfies others: Worker = Human + Robot; every workstation has exactly one worker and each worker is in exactly one workstation; each component has exactly one workstation; components have parts and materials have no parts; no human-robot mixing per workstation; no component is its own part; C2 has dangerous part M2 and is marked dangerous; dangerous component C2 is assembled only by robots.\n    }\n} for 3 Workstation, 3 Worker, 4 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        workers = WS1->W1 + WS2->W2 + WS3->W3\n        succ = WS1->WS2 + WS2->WS3 + WS3->WS1 // breaks the line: cycle exists, so there is no simple line from begin to end\n\n        Worker = W1 + W2 + W3\n        no Human\n        Robot = W1 + W2 + W3\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        no Dangerous\n\n        parts = C1->M1 + C2->M1\n        workstation = C1->WS2 + C2->WS3\n\n        // Negative: succ forms a cycle (WS1->WS2->WS3->WS1), violating the single line requirement between begin (WS1) and end (WS3).\n        // Satisfies others: all workers are robots; each workstation has one worker and each worker is in exactly one workstation; each component has exactly one workstation; components have parts and the material has no parts; no human-robot mixing; no component is its own part; no dangerous parts/components used.\n    }\n} for 3 Workstation, 3 Worker, 3 Product expect 0",
                "input tokens": 3962,
                "output tokens": 6474
            },
            {
                "description": "The parts of a component must be assembled before it in the production line",
                "pred": "this/inv10",
                "oracle": "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : c.parts & Component | c.workstation in p.workstation.^succ\n}",
                "erroneous": [
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | p in succ.{c.workstation}\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | c.workstation in p.workstation.^succ\n }",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.parts.workstation.^succ\n}",
                    "{\n    // The parts of a component must be assembled before it in the production line\n    all c: Component, p: c.parts | p.workstation in c.workstation.~succ\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t//all c : Component | c.parts.workstation in c.workstation \n  \tall c : Component, p : c.parts, ws1 : p.workstation, ws2 : c.workstation | ws1 in ws2.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts |\n        all ws: c.workstation, wsPart: p.workstation |\n            wsPart in ws.(~succ) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts | \n  \t\tp.workstation in (^succ).c.workstation\n  \n  \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.workstation in c.parts.workstation.*succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component | all p: c.parts | \n        some ps, pc: Workstation | \n            ps in p.workstation and \n            pc in c.workstation and \n            ps in pc.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall a, b: Component | a in b.parts implies b in a.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component | let\n\t\tws = c.workstation,\n\t\tprevParts = (ws.succ.parts - c.parts) | \n\t\tprevParts not in ws.parts\n\n}",
                    "{\n    // Para cada componente c, todas as partes de c devem ser montadas\n    // em esta\u00e7\u00f5es que precedem a esta\u00e7\u00e3o onde c \u00e9 montado\n    all c : Component , p : c.parts | \n            some wsPart, wsComponent : Workstation | \n                p in workstation.wsPart and \n                c in workstation.wsComponent and\n                wsComponent in wsPart.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in ws implies before c in ws\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in  c.parts.workstation.*succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies before(all p: Product | p in c.^parts implies some p.workstation or p in Material)\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.^parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts |\n        some ws: c.workstation, wsPart: p.workstation |\n            wsPart in ws.(~succ) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \n\tall c:Component | no (workstation.(c.workstation.^succ) & c.^parts)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : (c.parts) | no( c.workstation.succ & p.workstation.succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.parts | one ws2: Workstation | ws2 in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | c.workstation in p.workstation.*succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: (c.parts & Component) | c.workstation in p.workstation.*succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n\t\tall p: c.parts |\n\t\t\tlet ws1 = p.workstation, ws2 = c.workstation |\n\t\t\t\tp not in Material implies (\n\t\t\t\t\tsome w1: ws1, w2: ws2 | w1 in w2.^succ\n\t\t\t\t)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | p.workstation not in c.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation != begin => all c1 : parts.c & Component | c1.workstation = end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation != begin => all c1 : c.^parts & Component | c1.workstation = end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\nall c : Component |\n      all p : c.parts |\n          some w : Workstation\n            |\n              p.workstation in w.^succ and w in c.workstation\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | all p : c.parts | c.workstation in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c : Component | c.workstation in c.parts.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies c.workstation in c.^parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | c.workstation in p.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation in c.workstation.*(~succ) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation != end => all c1 : parts.c & Component | no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | one c.workstation.succ => (all c1 : parts.c & Component | c1.workstation = begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  // all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n  all c : Component | c.workstation != begin => all p : c.parts & Component | p.workstation = end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n//all c1,c2 : Component | c1 in c2.parts implies c2.workstation in c1.workstation.^succ\n  all c : Component | parts.c in c.workstation.^succ.parts\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | all comp : c.parts | comp in Component => comp.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in (c.^parts).workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, w : Workstation| c in workstation.w implies c.^(parts) in (workstation.(^(succ).w)).^(parts)\n \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.^succ or lone Workstation or no c.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies no c1.workstation & c2.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | no c.parts => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | all c1 : c.parts & Component | one c1.workstation and c1.workstation != end => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | all c1 : c.^parts & Component | one c1.workstation and c1.workstation != end => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation != end => all c1 : parts.c & Component | c1.workstation != c.workstation and c1.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (one c.workstation.succ => (all c1 : parts.c & Component | c.workstation != c1.workstation and (c1.workstation = begin)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | one c.workstation implies all c1 : c.^parts & Component | c1.workstation = end \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation != begin implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n  //all c : Component | (some p : c.parts & Component | p.workstation != end) implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | ((c.workstation in p.workstation.succ) or (c.workstation in end and p.workstation in begin)) or c.workstation = p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (one c.workstation) implies (all c1 : (^parts).c & Component | no c1.workstation or c1.workstation = begin)\n  //all c : Component | (some p : c.parts & Component | p.workstation != end) implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | some c.workstation => all c1 : parts.c & Component | c1.workstation = begin or no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p: Component, c: Component | p in c.*parts => c.workstation in p.workstation.^succ\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.*succ in c.parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.^succ in c.parts.workstation.^succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no c.parts or some (c.parts & Component) => c.parts.^workstation not in c.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no c.parts or some (c.parts & Component) => c.parts.workstation.^succ not in c.workstation.*succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.parts.workstation.*succ not in c.workstation.*succ\n  Component.workstation != Component.parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.parts.workstation.*succ not in c.workstation.*succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall a,b : Component | b in a.parts implies a.workstation in ^succ.workstation.b\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.parts | one ws2: Workstation | ws2 in p.workstation or p in Material\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.*parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation in c.workstation \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tno Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | parts.c in Component implies c.~parts.workstation in c.workstation.succ \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in end and ws_p in ws_c.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in (begin.^succ & c.workstation)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c1, c2: Component | c2 in c1.^parts => c2 in c1.workstation.^~succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all p: Product | all parts: p.parts | some w: Workstation | parts in w\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | (all p: c.parts | p in workstation.(*succ.(c.workstation)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.^succ or lone Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | no c.parts or c.parts in Material or c.parts.workstation not in c.workstation.^succ or lone Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in c.workstation implies once ws in ((c.parts).workstation  & (c.parts).workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall p : Product | all main : Product | p in main.^(parts.parts) implies  \t\t\tmain.workstation in p.^(succ.succ)\n  \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.*(~succ) implies c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.(~parts).workstation.^(~succ)-c in c.workstation.~succ-c implies \t c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.workstation in c.parts.workstation.succ or c.parts = none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | #c.parts != 0 implies c.workstation in c.parts.workstation.*succ \n         \n}",
                    "{\n    // Le parti di un componente devono essere assemblate prima del componente nella linea di produzione\n    all c: Component, p: Product |\n        p in c.parts implies \n            // Se una parte \u00e8 un componente, deve essere assemblato in una workstation precedente\n            all ws1: Workstation, ws2: Workstation |\n                ws1 in p.workstation and ws2 in c.workstation and ws1 != ws2 implies ws1 in ws2.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies c.workstation in c.^parts.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws2 = ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 in ws2.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.^(Component <: parts. Component <:workstation) in ^succ.(c.workstation) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies no p.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies p.workstation = end or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | some c.workstation implies some p.workstation\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | before_[p.workstation, c.workstation]\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in (c.^parts).workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in (c.*parts).workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, w: c.workstation | all p: c.parts | w in p.^succ\n }",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | none = (c.workstation).workers => none = (c.workstation).succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in (c.parts & Component).workstation.^succ and c.workstation not in (c.parts & Component).workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.^parts in workstation.^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (c.parts + c.workstation) in (c.parts + c.workstation.succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | no(parts.c.workstation & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation != begin => some c.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (c.parts & Component).workstation != end => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | all c1 : c.parts & Component | one c1.workstation => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (one c.workstation.succ => (all c1 : parts.c & Component | no c1.workstation))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (c.workstation != end => (all c1 : parts.c & Component | no c1.workstation or c1.workstation = begin))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (c.workstation != end => (all c1 : parts.c & Component | c.workstation != c1.workstation and (no c1.workstation or c1.workstation = begin)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (one c.workstation.succ => (all c1 : parts.c & Component | c.workstation != c1.workstation and (no c1.workstation or c1.workstation = begin)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c1.workstation = begin) or (c.workstation = end and c1.workstation != begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and no c1.workstation) or (c.workstation = end and c1.workstation != begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and no c1.workstation) or (no c.workstation and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c1.workstation = begin) or (no c.workstation and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c1.workstation = begin) or (c.workstation = end and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c.workstation != begin and c1.workstation = begin) or (c.workstation = end and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation = begin => all c1 : c.parts & Component | c1.workstation = begin or no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | c.workstation = begin => all c1 : parts.c & Component | c1.workstation = begin or no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | some c1 : c.parts & Component | some c1.workstation implies no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n   all c: Component | {\n        all p: c.parts | {\n            all w1, w2: c.workstation |\n                w1 in w2.succ implies p.workstation in w2\n        }\n    }\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation = end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation = end and c1.workstation != begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  // all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n  all c : Component | c.workstation != begin => all p : c.parts & Component | p.workstation in end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  // all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n  all c : Component | some p : c.parts & Component | p.workstation != end implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (c.workstation in Workstation - end) implies (all c1 : (^parts).c & Component | c1.workstation = begin)\n  //all c : Component | (some p : c.parts & Component | p.workstation != end) implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (one c.workstation) implies (all c1 : (^parts).c & Component | c1.workstation = begin)\n  //all c : Component | (some p : c.parts & Component | p.workstation != end) implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t// all c : Component | one (c.workstation).succ => \n  all c : Component | (one c.workstation) implies (all c1 : (^parts).c & Component | no c1.workstation)\n  //all c : Component | (some p : c.parts & Component | p.workstation != end) implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | (c.workstation in p.workstation.succ) or (c.workstation in begin and p.workstation in end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | (c.workstation in p.workstation.succ) or (c.workstation in end and p.workstation in begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component| (c.parts) in (workstation.( ^(succ).(c.workstation) )).parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | not c.parts.workstation in c.workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tno c: Component | c.workstation in c.parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall c: Component | all p: parts.c | c.workstation in p.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c : Component | c.workstation not in begin implies c.parts.workstation in end\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t(all c: Component|\n  \tc.parts.workstation in end iff c.workstation in begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p: Component, c: Component | p in c.*parts => c.workstation in p.workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n  all c: Component | \n    all p: c.parts | \n      (p = c or p in c.^succ)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all wsfromParts:c.^parts.workstation.^succ | c.workstation in wsfromParts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all wsfromParts:c.^parts.workstation.^succ | c.workstation in wsfromParts-c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | all p:c.parts | c.workstation not in p.^workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | all p:c.^parts.workstation | c.workstation not in p\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | Workstation in *succ.c.workstation \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | Workstation in *succ.(c.workstation) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.^parts.workstation not in (begin + end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | lone ws:c.^parts.workstation | c.workstation in ws\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.parts.workstation.*succ in c.workstation.*succ\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.workstation.succ in c.parts.workstation.*succ \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.workstation not in c.parts.workstation.*succ \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no (c.workstation.*succ & c.parts.workstation.*succ)\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.^succ in c.parts.workstation.*succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.*succ in c.*parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.*succ in c.^parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no c.parts or some (c.parts & Component) => c.workstation not in c.parts.workstation.^succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.parts.workstation.*succ not in c.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.parts.workstation.^succ && c.workstation not in c.parts.workstation\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation not in begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | some c.parts implies c.workstation not in begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | some c.parts implies c.workstation in end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1, c2 : Component | all w1, w2 : Workstation | w1 in c1.workstation and w2 in c2.workstation and c2 in c1.^parts implies w2 in w1.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | Workstation in c.workstation => all p: c.parts | Workstation in c\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.^parts | one ws2: Workstation | ws2 in p.workstation or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.*parts | one ws2: Workstation | ws2 in p.workstation or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | (c.workstation in Workstation) => all p: c.parts | p in Material or some ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | (Workstation in c.workstation) => all p: c.parts | p in Material or some ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.^parts | p in Material or one ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.*parts | p in Material or one ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.parts | ws in p.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.parts | ws in p.workstation.^succ or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c1, c2: Component | all w1, w2: Workstation | w1 in c1.workstation and w2 in c2.workstation and c2 in c1.^parts => w1 in w1.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tsome Component.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c in Component.parts implies end not in c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | parts.c in Component implies c.~parts.workstation in c.workstation.~succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts & Component {\n      \tearlierStation[p.workstation, c.workstation]\n    \tc.workstation.*succ in p.workstation.*succ\n      \tp.workstation.*succ not in c.workstation.*succ\n    }\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts & Component {\n      \tearlierStation[p.workstation, c.workstation]\n    \t//c.workstation.*succ in p.workstation.*succ\n      \t//p.workstation.*succ not in c.workstation.*succ\n    }\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c1, c2: Component | c1 in c2.parts implies some ws: c1.workstation | ws in c2.workstation.*(succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n      all c: Component, p: c.parts | one ws1, ws2: c.workstation | ws1 in p.workstation and ws2 in c.workstation and ws1 in ws2.^succ\n\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in c.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | c.workstation.succ in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | c.workstation.succ in p.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: Component |\n  \t\tp in c.^parts => p.workstation in c.workstation.~succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: Component |\n  \t\tp in c.^parts => p.workstation in c.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation = begin or c.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p : c.parts | some ws:Workstation |\n  \t\tws in p.workstation\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    \tws_p in ws_c.^succ and ws_p in begin.^succ and ws_c in begin.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in ws_c.^succ and ws_p in begin.^succ and ws_c in end.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in ws_c.^succ and ws_c in end.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in ws_c.^succ and ws_p in end.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation | one ws_e : end |\n    ws_e in ws_c.^succ \n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_p: p.workstation | one ws_e : end |\n    ws_e in ws_p.^succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in (p.workstation.^succ & c.workstation)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in (begin.*succ & c.workstation)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts | \n        some ws : c.workstation, wp : p.workstation |\n            wp not in ws.^succ\n  \n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts & Component | \n  \t\tsome c.workstation & p.workstation\n  \n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts & Component | \n  \t\tc.workstation = p.workstation\n  \n  \n}",
                    "{\n    // As partes de um componente devem ser montadas antes do pr\u00f3prio componente\n    all c : Component | \n        all p : c.parts | \n            p.workstation in c.workstation.~succ and\n            // Tamb\u00e9m garantimos que o componente \u00e9 montado na mesma esta\u00e7\u00e3o\n            c.workstation in p.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all c_parts: c.parts | \n  \t\tsome c.workstation implies some (c_parts.workstation & end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all c_parts: (c.parts & Component) | \n  \t\tsome c.workstation implies some (c_parts.workstation & end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all c_parts: (c.parts & Component) | \n  \t\tsome c.workstation implies \n  \t\t\tsome (c_parts.workstation & end) and no (c_parts.workstation & begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component | all p: c.parts |\n        lone ps: Workstation | \n            ps in p.workstation and \n            lone pc: Workstation | \n                pc in c.workstation and \n                ps in pc.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component, w: Workstation | w in c.workstation implies ( c.parts.workstation in *(succ).w)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : c.*parts | c.workstation in p.workstation.^succ\n}",
                    "{\n    // Para cada componente c, todas as suas partes p devem ser montadas\n    // em esta\u00e7\u00f5es que precedem a esta\u00e7\u00e3o onde c \u00e9 montado\n    all c : Component, p : c.parts | \n        some wsPart, wsComponent : Workstation | \n            p in workstation.wsPart and \n            c in workstation.wsComponent and \n            wsComponent-> wsPart in succ\n}",
                    "{\n    // Para cada componente c, todas as suas partes p devem ser montadas\n    // em esta\u00e7\u00f5es que precedem a esta\u00e7\u00e3o onde c \u00e9 montado\n    all c : Component, p : c.parts | \n        one w : Workstation | \n            p in workstation.w and \n            c in workstation.w\n}",
                    "{\n    // Para cada componente c, todas as suas partes p devem ser montadas\n    // em esta\u00e7\u00f5es que precedem a esta\u00e7\u00e3o onde c \u00e9 montado\n    all c : Component, p : c.parts | (one w : Workstation |  p in workstation.w and c in workstation.w)\n\n\tall c : Component, p : c.parts | c in p.*succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | no c.parts or c.parts in Material or c.parts.workstation not in (c.workstation + c.workstation.^succ) or lone Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (no c.parts or c.parts in Material or c.parts.workstation not in (c.workstation + c.workstation.^succ) or lone Workstation) and one c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (no c.parts or c.parts in Material or no (c.parts.workstation & (c.workstation + c.workstation.^succ)) or lone Workstation) and one c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (no c.parts or c.parts in Material or no (c.parts.workstation & c.workstation.^succ) or lone Workstation) and one c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | all w: c.workstation | w in p.workstation.succ or c.workstation = p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | p in Component \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in c implies before c in ws\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in c.workstation implies once ws in (c.parts).workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in c.workstation implies once ws in ((c.parts).workstation  & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in (c.parts).workstation implies ws in (c.workstation  & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | (ws in (c.parts).workstation) or (ws in (c.parts).workstation.^succ) implies before ws in (c.workstation & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in ((c.parts).workstation & (c.parts).workstation.^succ) implies before ws in c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in Component and ws in (c.parts).workstation implies ws in (c.workstation & c.workstation.^succ) \n  }",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in Component and ws in (c.parts).workstation and ws in (c.parts).workstation implies ws in c.workstation \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in (c.parts).workstation and ws in (c.parts).workstation.^succ implies ws in c.workstation \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t  all c: Component, ws: Workstation, p: c.parts | ws in p.workstation or ws in p.workstation.^succ implies ws in c.workstation\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c: Component, p: c.parts&Component |\n    all ws_part: p.workstation, ws_c: c.workstation |\n      ws_part in begin.^succ and ws_part in ws_c.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n\tall disj c1, c2 : Component | c2 in c1.parts implies c2.workstation in (c1.workstation.*succ - c1.workstation.^succ) \t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n\tall disj c1, c2 : Component | c2 in c1.parts implies c2.workstation in (c1.workstation.*succ - c1.workstation.^succ - c1.workstation) \t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | all p : c.parts | p in Component implies p.workstation not in c.^workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall p : Product | all main : Product | p in main.^(parts.parts) implies  \t\t\tmain.workstation in p.workstation.^(succ.succ)\n  \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | one c.workstation \n\t\t\t\t\timplies\n\t\t\t\t\t(all p:c.^parts | one p.workstation) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component , p : ^parts.c |\n  \t\tp.workstation in ^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component , p : parts.c |\n  \t\tp.workstation in ^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation in ^succ.c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : c.parts | c.workstation in ^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall x: Component, w : x.workstation, y: x.parts & Component | y.workstation in (w.succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1.parts in c2.^parts implies c1.workstation not in c2.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1.parts in c2.parts implies c1.workstation not in c2.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies c1.workstation not in c2.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies c1.workstation not in c2.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies c1.workstation not in c2.workstation.^succ and (c1 != c2)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  some c1 : Component | all c2 : c1.^succ | some p : c2.parts |  p in c1 \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component , c2 : Component | c1 in c2.parts implies c2.workstation in c1.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.(~parts).workstation in c.workstation.~succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.*(~succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.*(~succ) iff c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.^(~succ) implies \t c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.(~parts).workstation.^(~succ)-c.workstation in c.workstation.~succ-c.workstation implies \t c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.workstation in c.parts.workstation.succ or c.parts.workstation = \tnone\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tsome c: Component, p: c.parts |\n        some ws: c.workstation, wsPart: p.workstation |\n            wsPart in ws.(~succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall m:Material | all c:Component | m in c.parts and c.workstation = none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall m:Material | some c:Component | m in c.parts and c.workstation = none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall m:Material | m in Component.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.parts.workstation != none implies c.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies c.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies \n  \t\tc.^parts.workstation.^succ in c.workstation.^~succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies\n  \t\tc.workstation in c.^parts.workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws: Workstation | ws in p.workstation and ws not in end)\n\t\t\tand (some ws1: Workstation | ws1 in c.workstation and ws1 in end  )\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws: Workstation | ws in p.workstation )\n\t\t\tand (some ws1: Workstation | ws1 in c.workstation and ws1 in end  )\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(#p.workstation > 0 implies (some ws: Workstation | ws in p.workstation)\n\t\t\tand some ws2: Workstation | ws2 in end and ws2 in c.workstation\n)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws1 in end and ws1 in c.workstation and\n  \t\t\t(#p.workstation > 0 implies ws2 in p.workstation) )\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation and ws2 in end and ws2 = ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall m: Material | m.parts = none\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws2 = ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall m: Material | m.parts = none\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws2 in ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 = ws2.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \tall m: Material | #m.parts = 0\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 in ws2.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \tall m: Material | #m.parts = 0\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 in ws2.*succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | \n  \t\t\t\tp not in Material implies (\n  \t\t\t\tws2 = c.workstation and ws1 in p.workstation  and ws1 in ws2.*succ))\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies all p: Product | some p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies some p.workstation or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies p.workstation = end - begin or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies p.workstation = end and p.workstation != begin or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p : Product | all p : p.parts | (p in Component implies (some ws : p.workstation.^~succ | ws in p.workstation)) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p : Product | all p : p.parts | (p in Component implies (some ws : p.workstation.*~succ | ws in p.workstation)) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p : Product | all pp : p.parts | (pp in Component implies (some ws : p.workstation.*~succ | ws in pp.workstation)) \n}"
                ],
                "instances": "run Neg1 {\n    some disj WS1, WS2 : Workstation | some disj W1, W2 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        // Workstations and line\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n        succ = WS1->WS2 // single line WS1 -> WS2\n\n        // Workers and assignment\n        Worker = W1 + W2\n        Human = W1\n        Robot = W2\n        workers = WS1->W1 + WS2->W2 // each WS has exactly one worker; no mixing\n\n        // Products and subsets\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        no Dangerous\n\n        // Parts and assembly workstation\n        parts = C1->C2 + C2->M1 // components have parts; materials have none\n        workstation = C1->WS1 + C2->WS2 // C2 assembled after C1 along the line\n\n        // Negative: C1 has part C2, but C2 is assembled later (WS2) than C1 (WS1), violating \"parts before component\".\n        // Satisfies others: single line from begin to end; each WS has workers and each worker in exactly one WS;\n        // no human-robot mixing; components not their own parts; no dangerous items; dangerous-by-part rule vacuously holds.\n    }\n} for 2 Workstation, 2 Worker, 3 Product expect 0\n\nrun Neg2 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1, M2 : Material {\n        // Workstations and line\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        succ = WS1->WS2 + WS2->WS3 // single line WS1 -> WS2 -> WS3\n\n        // Workers and assignment\n        Worker = W1 + W2 + W3\n        Human = W1 + W2\n        Robot = W3\n        workers = WS1->W1 + WS2->W2 + WS3->W3 // each WS has exactly one worker; no mixing\n\n        // Products and subsets\n        Product = C1 + C2 + M1 + M2\n        Material = M1 + M2\n        Component = C1 + C2\n        Dangerous = M2 + C2 // M2 is dangerous; C2 (using M2) is also dangerous\n\n        // Parts and assembly workstation\n        parts = C1->C2 + C1->M1 + C2->M2 // components have parts; materials have none\n        workstation = C1->WS2 + C2->WS3 // C2 assembled after C1\n\n        // Negative: C1 has part C2, but C2 is assembled later (WS3) than C1 (WS2), violating \"parts before component\".\n        // Satisfies others: single line from begin to end; each WS has workers and each worker in exactly one WS;\n        // no human-robot mixing; components not their own parts; C2 uses dangerous part M2 so C2 is dangerous;\n        // dangerous component C2 is assembled by robots at WS3.\n    }\n} for 3 Workstation, 3 Worker, 4 Product expect 0\n\nrun Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1, W2, W3 : Worker | some disj C1, C2 : Component | some disj M1 : Material {\n        // Workstations and line\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n        succ = WS1->WS2 + WS2->WS3 // single line WS1 -> WS2 -> WS3\n\n        // Workers and assignment\n        Worker = W1 + W2 + W3\n        no Human\n        Robot = W1 + W2 + W3\n        workers = WS1->W1 + WS2->W2 + WS3->W3 // each WS has exactly one worker; no mixing\n\n        // Products and subsets\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        no Dangerous\n\n        // Parts and assembly workstation\n        parts = C1->C2 + C2->M1 // components have parts; materials have none\n        workstation = C1->WS1 + C2->WS3 // C2 assembled after C1\n\n        // Negative: C1 has part C2, but C2 is assembled later (WS3) than C1 (WS1), violating \"parts before component\".\n        // Satisfies others: single line from begin to end; each WS has workers and each worker in exactly one WS;\n        // no human-robot mixing; components not their own parts; no dangerous items; dangerous-by-part rule vacuously holds.\n    }\n} for 3 Workstation, 3 Worker, 3 Product expect 0",
                "input tokens": 4111,
                "output tokens": 8310
            }
        ]
    }
]