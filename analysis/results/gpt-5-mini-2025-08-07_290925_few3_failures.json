{
    "Photo sharing social network": {
        "this/inv2": {
            "parse": [
                "run Pos1 {\n    // Positive: single user does not follow themselves; the single photo is posted by exactly one user\n    some disj U1 : User | some disj P1 : Photo | some disj D1 : Day {\n        User = U1\n        Photo = P1\n        Day = D1\n        Influencer = none\n        Ad = none\n        follows = none\n        suggested = none->none\n        sees = none->none\n        posts = U1->P1\n        Photo.date = P1->D1\n    }\n} for 1 User, 1 Photo, 1 Day expect 1",
                "run Pos2 {\n    // Positive: two users follow each other but no one follows themselves; each photo is posted by exactly one user\n    some disj U1, U2 : User | some disj P1, P2 : Photo | some disj D1, D2 : Day {\n        User = U1 + U2\n        Photo = P1 + P2\n        Day = D1 + D2\n        Influencer = U1\n        Ad = P2\n        follows = U1->U2 + U2->U1\n        suggested = U1->U2\n        sees = U1->P1 + U2->P2\n        posts = U1->P1 + U2->P2\n        Photo.date = P1->D1 + P2->D2\n    }\n} for 2 User, 2 Photo, 2 Day expect 1",
                "run Pos3 {\n    // Positive: two users exist, there are no photos (vacuously every photo is posted by one user); no one follows themselves\n    some disj U1, U2 : User | some disj D1 : Day {\n        User = U1 + U2\n        Photo = none\n        Day = D1\n        Influencer = none\n        Ad = none\n        follows = none\n        suggested = none->none\n        sees = none->none\n        posts = none->none\n        Photo.date = none->none\n    }\n} for 2 User, 0 Photo, 1 Day expect 1",
                "run Neg1 {\n    // Negative: the single user follows themselves (violates \"Users cannot follow themselves\"); the photo is posted by exactly one user\n    some disj U1 : User | some disj P1 : Photo | some disj D1 : Day {\n        User = U1\n        Photo = P1\n        Day = D1\n        Influencer = none\n        Ad = none\n        follows = U1->U1\n        suggested = none->none\n        sees = none->none\n        posts = U1->P1\n        Photo.date = P1->D1\n    }\n} for 1 User, 1 Photo, 1 Day expect 0",
                "run Neg2 {\n    // Negative: one of the users follows themselves (violates the requirement); both photos are still posted by exactly one user each\n    some disj U1, U2 : User | some disj P1, P2 : Photo | some disj D1, D2 : Day {\n        User = U1 + U2\n        Photo = P1 + P2\n        Day = D1 + D2\n        Influencer = U2\n        Ad = none\n        follows = U2->U2 + U1->U2\n        suggested = none->none\n        sees = none->none\n        posts = U1->P1 + U1->P2\n        Photo.date = P1->D1 + P2->D2\n    }\n} for 2 User, 2 Photo, 2 Day expect 0",
                "run Neg3 {\n    // Negative: there are no photos (so photo constraint vacuously holds) but a user follows themselves (violates \"Users cannot follow themselves\")\n    some disj U1 : User | some disj D1 : Day {\n        User = U1\n        Photo = none\n        Day = D1\n        Influencer = none\n        Ad = none\n        follows = U1->U1\n        suggested = none->none\n        sees = none->none\n        posts = none->none\n        Photo.date = none->none\n    }\n} for 1 User, 0 Photo, 1 Day expect 0"
            ]
        },
        "this/inv3": {
            "valid": [
                "run Neg1 {\n    some disj U1, U2 : User |\n    some disj P1 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2\n        Influencer = none\n        Photo = P1\n        Ad = P1\n        Day = D1\n        follows = none->none\n        sees = U1->P1          // U2 missing -> violates \"ads visible to everyone\"\n        posts = U1->P1\n        suggested = none->none\n        date = P1->D1\n    }\n} for 2 User, 1 Photo, 1 Day expect 0",
                "run Neg3 {\n    some disj U1, U2 : User |\n    some disj P1 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2\n        Influencer = none\n        Photo = P1\n        Ad = none\n        Day = D1\n        follows = U1->U2\n        sees = none->none      // no one sees P1 despite U1 following U2 -> violation\n        posts = U2->P1\n        suggested = none->none\n        date = P1->D1\n    }\n} for 2 User, 1 Photo, 1 Day expect 0"
            ]
        },
        "this/inv4": {
            "parse": [
                "run Pos1 {\n    some disj U1 : User |\n    some disj P1 : Photo |\n    some disj D1 : Day {\n        User = U1\n        Photo = P1\n        Day = D1\n\n        Influencer = none\n        Ad = P1\n\n        follows = none\n        posts = U1->P1\n        suggested = none\n        sees = U1->P1\n\n        Photo.date = P1->D1\n    }\n} for 1 User, 1 Photo, 1 Day expect 1",
                "run Pos2 {\n    some disj U1, U2 : User |\n    some disj P1, P2, P3 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2\n        Photo = P1 + P2 + P3\n        Day = D1\n\n        Influencer = none\n        Ad = P3\n\n        follows = U1->U2\n        posts = U1->P1 + U1->P2 + U2->P3\n        suggested = none\n\n        /* sees: all users see ads (P3), non-ads (P1,P2) are seen only by followers of their poster.\n           Here no one follows U1, so P1 and P2 are unseen. */\n        sees = U1->P3 + U2->P3\n\n        Photo.date = P1->D1 + P2->D1 + P3->D1\n    }\n} for 2 User, 3 Photo, 1 Day expect 1",
                "run Pos3 {\n    some disj U1, U2, U3 : User |\n    some disj P1, P2, P3 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2 + U3\n        Photo = P1 + P2 + P3\n        Day = D1\n\n        Influencer = U1\n        Ad = P1 + P2\n\n        follows = U2->U3 + U3->U1\n        posts = U1->P1 + U1->P2 + U3->P3\n        suggested = U1->U2\n\n        /* sees: all users see ads P1,P2; non-ad P3 (posted by U3) is only seen by U2 (who follows U3). */\n        sees = \n            U1->P1 + U1->P2 + U2->P1 + U2->P2 + U3->P1 + U3->P2\n            + U2->P3\n\n        Photo.date = P1->D1 + P2->D1 + P3->D1\n    }\n} for 3 User, 3 Photo, 1 Day expect 1",
                "run Neg1 {\n    some disj U1 : User |\n    some disj P1, P2 : Photo |\n    some disj D1 : Day {\n        User = U1\n        Photo = P1 + P2\n        Day = D1\n\n        Influencer = none\n        Ad = P1\n\n        follows = none\n        posts = U1->P1 + U1->P2\n        suggested = none\n\n        /* sees: all users (only U1) see ads (P1); non-ad P2 is seen only by followers of U1 (none). */\n        sees = U1->P1\n\n        Photo.date = P1->D1 + P2->D1\n    }\n} for 1 User, 2 Photo, 1 Day expect 0",
                "run Neg2 {\n    some disj U1, U2 : User |\n    some disj P1, P2 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2\n        Photo = P1 + P2\n        Day = D1\n\n        Influencer = none\n        Ad = P1\n\n        follows = U2->U1\n        posts = U1->P1 + U1->P2\n        suggested = none\n\n        /* sees: all users see ad P1; non-ad P2 (posted by U1) is seen by U2 because U2 follows U1. */\n        sees = U1->P1 + U2->P1 + U2->P2\n\n        Photo.date = P1->D1 + P2->D1\n    }\n} for 2 User, 2 Photo, 1 Day expect 0",
                "run Neg3 {\n    some disj U1, U2 : User |\n    some disj P1, P2, P3 : Photo |\n    some disj D1, D2 : Day {\n        User = U1 + U2\n        Photo = P1 + P2 + P3\n        Day = D1 + D2\n\n        Influencer = U2\n        Ad = P1 + P3\n\n        follows = U1->U2\n        posts = U1->P1 + U1->P2 + U2->P3\n        suggested = none\n\n        /* sees: all users see ads P1 and P3; non-ad P2 (posted by U1) is seen only by followers of U1 (none). */\n        sees = U1->P1 + U1->P3 + U2->P1 + U2->P3\n\n        Photo.date = P1->D1 + P2->D2 + P3->D1\n    }\n} for 2 User, 3 Photo, 2 Day expect 0"
            ]
        },
        "this/inv5": {
            "parse": [
                "run PosInstance1 {\n    // Positive: Influencer User2 is followed by everyone else (User1). All other requirements are satisfied.\n    some disj User1, User2 : User |\n    some disj Photo1, Photo2 : Photo |\n    some disj Day1, Day2 : Day {\n        User = User1 + User2\n        Influencer = User2\n        follows = User1->User2\n        suggested = none\n        Photo = Photo1 + Photo2\n        Ad = Photo2\n        posts = User1->Photo1 + User2->Photo2\n        Photo.date = Photo1->Day1 + Photo2->Day2\n        sees = User1->Photo2 + User2->Photo2\n    }\n} for 2 User, 2 Photo, 2 Day expect 1",
                "run PosInstance2 {\n    // Positive: Influencer User2 is followed by everyone else (User1 and User3). No ads exist, and all other requirements are satisfied.\n    some disj User1, User2, User3 : User |\n    some disj Photo1, Photo2 : Photo |\n    some disj Day1, Day2 : Day {\n        User = User1 + User2 + User3\n        Influencer = User2\n        follows = User1->User2 + User3->User2\n        suggested = none\n        Photo = Photo1 + Photo2\n        Ad = none\n        posts = User1->Photo1 + User2->Photo2\n        Photo.date = Photo1->Day1 + Photo2->Day2\n        sees = User1->Photo2 + User3->Photo2\n    }\n} for 3 User, 2 Photo, 2 Day expect 1",
                "run PosInstance3 {\n    // Positive: There are no influencers (Influencer = none), so \"Influencers are followed by everyone else\" holds vacuously. All other requirements are satisfied.\n    some disj User1 : User |\n    some disj Photo1 : Photo |\n    some disj Day1 : Day {\n        User = User1\n        Influencer = none\n        follows = none\n        suggested = none\n        Photo = Photo1\n        Ad = none\n        posts = User1->Photo1\n        Photo.date = Photo1->Day1\n        sees = none\n    }\n} for 1 User, 1 Photo, 1 Day expect 1",
                "run NegInstance1 {\n    // Negative: Influencer User1 is NOT followed by User2 (no one follows User1), so requirement fails. Other requirements satisfied.\n    some disj User1, User2 : User |\n    some disj Photo1 : Photo |\n    some disj Day1 : Day {\n        User = User1 + User2\n        Influencer = User1\n        follows = none\n        suggested = none\n        Photo = Photo1\n        Ad = none\n        posts = User1->Photo1\n        Photo.date = Photo1->Day1\n        sees = none\n    }\n} for 2 User, 1 Photo, 1 Day expect 0",
                "run NegInstance2 {\n    // Negative: Influencer User1 is not followed by User3 (only User2 follows User1), so requirement fails. Ads present are seen by everyone as required.\n    some disj User1, User2, User3 : User |\n    some disj Photo1, Photo2 : Photo |\n    some disj Day1, Day2 : Day {\n        User = User1 + User2 + User3\n        Influencer = User1\n        follows = User2->User1\n        suggested = none\n        Photo = Photo1 + Photo2\n        Ad = Photo1\n        posts = User1->Photo1 + User2->Photo2\n        Photo.date = Photo1->Day1 + Photo2->Day2\n        sees = User1->Photo1 + User2->Photo1 + User3->Photo1\n    }\n} for 3 User, 2 Photo, 2 Day expect 0",
                "run NegInstance3 {\n    // Negative: There are two influencers (User1 and User2) but User3 follows User1 and does NOT follow User2, so the requirement fails. User1's posts are all ads as required.\n    some disj User1, User2, User3 : User |\n    some disj Photo1, Photo2, Photo3 : Photo |\n    some disj Day1, Day2 : Day {\n        User = User1 + User2 + User3\n        Influencer = User1 + User2\n        follows = User3->User1\n        suggested = none\n        Photo = Photo1 + Photo2 + Photo3\n        Ad = Photo1 + Photo2\n        posts = User1->Photo1 + User1->Photo2 + User2->Photo3\n        Photo.date = Photo1->Day1 + Photo2->Day1 + Photo3->Day2\n        sees = \n            // Ads (Photo1, Photo2) seen by everyone\n            User1->Photo1 + User2->Photo1 + User3->Photo1\n            + User1->Photo2 + User2->Photo2 + User3->Photo2\n            // Non-ad Photo3 seen only by followers of User2 (none)\n    }\n} for 3 User, 3 Photo, 2 Day expect 0"
            ]
        },
        "this/inv6": {
            "parse": [
                "run InstancePos1 {\n\tsome disj U1, U2 : User | some disj P1 : Photo | some disj D1 : Day {\n\t\t// Positive: single Influencer U1 posts on the only Day D1, so Influencers post every day is satisfied.\n\t\tUser = U1 + U2\n\t\tInfluencer = U1\n\t\tPhoto = P1\n\t\tAd = none\n\t\tDay = D1\n\n\t\t// follows: everyone else follows influencers; no one follows themselves.\n\t\tfollows = U2->U1\n\n\t\t// posts: each Photo is posted by exactly one User (P1 by U1).\n\t\tposts = U1->P1\n\n\t\t// sees: no ads exist; non-ads are seen only by followers of poster (U2 follows U1 so sees P1).\n\t\tsees = U2->P1\n\n\t\t// suggested unused in this instance\n\t\tsuggested = none\n\n\t\t// date of each photo\n\t\tdate = P1->D1\n\t}\n} for 2 User, 1 Photo, 1 Day expect 1",
                "run InstancePos2 {\n\tsome disj U1, U2, U3 : User | some disj P1, P2, P3, P4 : Photo | some disj D1, D2 : Day {\n\t\t// Positive: Two influencers (U1,U2) both post on both days D1 and D2.\n\t\t// U1 posts ads on both days (so all U1 posts are ads). U2 posts non-ads on both days.\n\t\tUser = U1 + U2 + U3\n\t\tInfluencer = U1 + U2\n\t\tPhoto = P1 + P2 + P3 + P4\n\t\tAd = P1 + P2\n\t\tDay = D1 + D2\n\n\t\t// follows: everyone else follows each influencer; no self-follows.\n\t\t// U1 and U2 (influencers) also follow each other to satisfy \"everyone else\".\n\t\tfollows = U2->U1 + U3->U1 + U1->U2 + U3->U2\n\n\t\t// posts: each photo posted by exactly one user\n\t\t// U1 posts P1 (D1) and P2 (D2) - both ads\n\t\t// U2 posts P3 (D1) and P4 (D2) - non-ads\n\t\tposts = U1->P1 + U1->P2 + U2->P3 + U2->P4\n\n\t\t// sees: all users see all ads (P1,P2).\n\t\t// non-ads (P3,P4) are seen only by users who follow their poster (U1 and U3 follow U2).\n\t\tsees = (User -> (P1 + P2)) + U1->P3 + U1->P4 + U3->P3 + U3->P4\n\n\t\t// suggested unused\n\t\tsuggested = none\n\n\t\t// dates\n\t\tdate = P1->D1 + P2->D2 + P3->D1 + P4->D2\n\t}\n} for 3 User, 4 Photo, 2 Day expect 1",
                "run InstancePos3 {\n\tsome disj U1, U2, U3, U4 : User | some disj P1, P2, P3, P4 : Photo | some disj D1, D2, D3 : Day {\n\t\t// Positive: Influencer U1 posts once on each of the three days D1,D2,D3.\n\t\t// Another user U2 posts an ad P4; since U2 posts an ad, all its posts (only P4) are ads.\n\t\tUser = U1 + U2 + U3 + U4\n\t\tInfluencer = U1\n\t\tPhoto = P1 + P2 + P3 + P4\n\t\tAd = P4\n\t\tDay = D1 + D2 + D3\n\n\t\t// follows: everyone else follows influencer U1; no self-follows.\n\t\tfollows = U2->U1 + U3->U1 + U4->U1\n\n\t\t// posts: U1 posts P1,P2,P3 on D1,D2,D3; U2 posts P4 (an ad).\n\t\tposts = U1->P1 + U1->P2 + U1->P3 + U2->P4\n\n\t\t// sees: all users see ads (P4). Non-ads (P1,P2,P3) are seen only by followers of U1 (U2,U3,U4).\n\t\tsees = (User -> P4) + U2->P1 + U2->P2 + U2->P3 + U3->P1 + U3->P2 + U3->P3 + U4->P1 + U4->P2 + U4->P3\n\n\t\t// suggested unused\n\t\tsuggested = none\n\n\t\t// dates\n\t\tdate = P1->D1 + P2->D2 + P3->D3 + P4->D1\n\t}\n} for 4 User, 4 Photo, 3 Day expect 1",
                "run InstanceNeg1 {\n\tsome disj U1, U2 : User | some disj P1 : Photo | some disj D1, D2 : Day {\n\t\t// Negative: Influencer U1 does not post on Day D2 (only posts on D1), so \"Influencers post every day\" fails.\n\t\tUser = U1 + U2\n\t\tInfluencer = U1\n\t\tPhoto = P1\n\t\tAd = none\n\t\tDay = D1 + D2\n\n\t\t// follows: everyone else follows influencer; no self-follows.\n\t\tfollows = U2->U1\n\n\t\t// posts: only P1 posted by U1 on D1 (no post on D2).\n\t\tposts = U1->P1\n\n\t\t// sees: no ads; non-ads are seen only by followers (U2 follows U1).\n\t\tsees = U2->P1\n\n\t\t// suggested unused\n\t\tsuggested = none\n\n\t\t// date\n\t\tdate = P1->D1\n\t}\n} for 2 User, 1 Photo, 2 Day expect 0",
                "run InstanceNeg2 {\n\tsome disj U1, U2, U3 : User | some disj P1, P2, P3 : Photo | some disj D1, D2 : Day {\n\t\t// Negative: Two influencers U1 and U2; U1 posts on both days, but U2 posts only on D1 (misses D2) -> requirement violated.\n\t\tUser = U1 + U2 + U3\n\t\tInfluencer = U1 + U2\n\t\tPhoto = P1 + P2 + P3\n\t\tAd = P1\n\t\tDay = D1 + D2\n\n\t\t// follows: everyone else follows each influencer; no self-follows.\n\t\t// U3 follows both influencers; U1 follows U2 and U2 follows U1 to satisfy \"everyone else\".\n\t\tfollows = U3->U1 + U3->U2 + U1->U2 + U2->U1\n\n\t\t// posts: U1 posts P1 (D1) and P2 (D2) and P1 is an ad -> since U1 posts an ad, all U1 posts must be ads.\n\t\t// To keep consistency, make P1 and P2 both ads (but we declared only P1 in Ad to make clear U2 misses a day).\n\t\t// Instead of forcing, we will keep U1 posts only P1 (ad on D1) and P2 (ad on D2) and mark both as ads.\n\t\tposts = U1->P1 + U1->P2 + U3->P3\n\n\t\t// Correct Ad set to include U1's posts\n\t\tAd = P1 + P2\n\n\t\t// sees: all users see ads (P1,P2). Non-ad P3 is seen only by followers of its poster (assume U3 posted P3 and is not followed by others).\n\t\tsees = (User -> (P1 + P2))\n\n\t\t// suggested unused\n\t\tsuggested = none\n\n\t\t// dates\n\t\tdate = P1->D1 + P2->D2 + P3->D1\n\t}\n} for 3 User, 3 Photo, 2 Day expect 0",
                "run InstanceNeg3 {\n\tsome disj U1, U2, U3, U4 : User | some disj P1, P2, P3 : Photo | some disj D1, D2 : Day {\n\t\t// Negative: Influencers U1 and U2 exist; U1 posts on both days, U2 posts on none -> U2 misses both days -> violation.\n\t\tUser = U1 + U2 + U3 + U4\n\t\tInfluencer = U1 + U2\n\t\tPhoto = P1 + P2 + P3\n\t\tAd = P3\n\t\tDay = D1 + D2\n\n\t\t// follows: everyone else follows each influencer; no self-follows.\n\t\tfollows = U2->U1 + U3->U1 + U4->U1 + U1->U2 + U3->U2 + U4->U2\n\n\t\t// posts: U1 posts P1 (D1) and P2 (D2) satisfying U1, U2 posts none (so U2 misses days).\n\t\t// U3 posts P3 which is an ad (so all U3's posts are ads \u2014 only P3).\n\t\tposts = U1->P1 + U1->P2 + U3->P3\n\n\t\t// sees: all users see ads (P3). Non-ads (P1,P2) are seen only by followers of U1 (U2,U3,U4).\n\t\tsees = (User -> P3) + U2->P1 + U2->P2 + U3->P1 + U3->P2 + U4->P1 + U4->P2\n\n\t\t// suggested unused\n\t\tsuggested = none\n\n\t\t// dates\n\t\tdate = P1->D1 + P2->D2 + P3->D1\n\t}\n} for 4 User, 3 Photo, 2 Day expect 0"
            ]
        },
        "this/inv7": {
            "parse": [
                "run Instance1 {\n    some disj U1,U2,U3 : User |\n    some disj P1,P2 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2 + U3\n        Photo = P1 + P2\n        Day = D1\n        Influencer = none\n        Ad = none\n\n        follows = U1->U2 + U2->U3\n\n        // Every photo is posted by one user\n        posts = U2->P1 + U3->P2\n\n        // No ads, so sees = non-ads posted by followed users:\n        sees = U1->P1 + U2->P2\n\n        // Suggested: U1 gets U3 (second-level), others none\n        suggested = U1->U3\n\n        // Photo dates\n        Photo.date = P1->D1 + P2->D1\n    }\n} for 3 User, 2 Photo, 1 Day expect 1",
                "run Instance2 {\n    some disj U1,U2,I1 : User |\n    some disj P1,P2 : Photo |\n    some disj D1,D2 : Day {\n        User = U1 + U2 + I1\n        Photo = P1 + P2\n        Day = D1 + D2\n        Influencer = I1\n        Ad = P1 + P2\n\n        // Influencer is followed by everyone else:\n        follows = U1->I1 + U2->I1 + I1->U2\n\n        // Influencer posts every day; since they post ads, all their posts are ads\n        posts = I1->P1 + I1->P2\n\n        // Everyone sees all ads (posted by everyone); no non-ads exist\n        sees = U1->P1 + U1->P2 + U2->P1 + U2->P2 + I1->P1 + I1->P2\n\n        // Suggested: U1 should be suggested U2 (I1 follows U2, U1 doesn't)\n        suggested = U1->U2\n\n        Photo.date = P1->D1 + P2->D2\n    }\n} for 3 User, 2 Photo, 2 Day expect 1",
                "run Instance3 {\n    some disj A,B,C,D : User |\n    some disj PB,PA : Photo |\n    some disj D1 : Day {\n        User = A + B + C + D\n        Photo = PB + PA\n        Day = D1\n        Influencer = none\n        Ad = PA\n\n        follows = A->B + A->C + B->D + C->D\n\n        // Posts: B posts a non-ad PB, D posts an ad PA\n        posts = B->PB + D->PA\n\n        // Everyone sees ads posted by everyone (PA), and non-ads only if they follow the poster (A follows B so sees PB)\n        sees = A->PB + A->PA + B->PA + C->PA + D->PA\n\n        // Suggested: A should be suggested D\n        suggested = A->D\n\n        Photo.date = PB->D1 + PA->D1\n    }\n} for 4 User, 2 Photo, 1 Day expect 1",
                "run Instance4 {\n    some disj U1,U2,U3 : User |\n    some disj P1,P2 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2 + U3\n        Photo = P1 + P2\n        Day = D1\n        Influencer = none\n        Ad = none\n\n        follows = U1->U2 + U2->U3\n\n        posts = U2->P1 + U3->P2\n\n        sees = U1->P1 + U2->P2\n\n        // Violation: suggested should include U3 for U1 but is empty here\n        suggested = none->none\n\n        Photo.date = P1->D1 + P2->D1\n    }\n} for 3 User, 2 Photo, 1 Day expect 0",
                "run Instance5 {\n    some disj U1,U2 : User |\n    some disj P1 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2\n        Photo = P1\n        Day = D1\n        Influencer = none\n        Ad = none\n\n        follows = U1->U2\n\n        posts = U2->P1\n\n        sees = U1->P1 + U2->none->none // keep sees for U2 empty; use no pair for U2\n\n        // Violation: suggested includes U2 even though U1 already follows U2\n        suggested = U1->U2\n\n        Photo.date = P1->D1\n    }\n} for 2 User, 1 Photo, 1 Day expect 0",
                "run Instance6 {\n    some disj U1,U2,U3 : User |\n    some disj P1,P2 : Photo |\n    some disj D1 : Day {\n        User = U1 + U2 + U3\n        Photo = P1 + P2\n        Day = D1\n        Influencer = none\n        Ad = none\n\n        follows = U1->U2  // U2 does not follow U3\n\n        posts = U2->P1 + U3->P2\n\n        sees = U1->P1 + U2->P2 + U3->none->none\n\n        // Violation: suggested incorrectly includes U3 for U1, but U2 does not follow U3\n        suggested = U1->U3\n\n        Photo.date = P1->D1 + P2->D1\n    }\n} for 3 User, 2 Photo, 1 Day expect 0"
            ]
        },
        "this/inv8": {
            "consistent": [
                "run PosInstance3 {\n    // Positive: Ads seen are only from followed or suggested users; influencer posts every day.\n    some disj I, A, B, C : User | some disj PI, PB, PC : Photo | some disj D1 : Day {\n        User = I + A + B + C\n        Influencer = I\n        Photo = PI + PB + PC\n        Ad = PI + PC\n        Day = D1\n\n        // follows:\n        // - everyone follows the influencer\n        // - I follows B (so B becomes suggested for A)\n        // - A follows I and B\n        // - B follows C (B posts non-ad), C posts an Ad\n        follows = A->I + B->I + C->I + I->B + A->B + B->C\n\n        // posts: influencer I posts PI (Ad) every day; B posts PB (non-ad); C posts PC (Ad)\n        posts = I->PI + B->PB + C->PC\n\n        // sees:\n        // - A sees PB (non-ad) \u2014 permitted because A follows B\n        // - A sees PC (Ad) \u2014 permitted because C is suggested (A follows I and I follows B and B follows C does not make C suggested to A directly; to keep C as suggested to A we keep I->C as well)\n        // Adjust follows so that C becomes suggested for A (I follows C)\n        // (we already set I->B; add I->C below by replacing follows above if needed)\n        // For clarity, ensure I follows C too so C is suggested for A:\n        // Note: we include I->C in follows explicitly:\n        follows = A->I + B->I + C->I + I->B + I->C + A->B + B->C\n\n        // Re-declare posts and sees after adjusting follows:\n        posts = I->PI + B->PB + C->PC\n        sees = A->PB + A->PC + I->PB\n\n        // suggested: A's suggested includes B and C (followed-by I)\n        suggested = A->B + A->C\n\n        date = PI->D1 + PB->D1 + PC->D1\n    }\n} for 4 User, 3 Photo, 1 Day expect 1"
            ],
            "previous": [
                "run NegInstance3 {\n    // Negative: A sees an ad posted by C, but C is neither followed by A nor suggested to A (suggested only includes B).\n    some disj I, A, B, C : User | some disj PI, PB, PC : Photo | some disj D1 : Day {\n        User = I + A + B + C\n        Influencer = I\n        Photo = PI + PB + PC\n        Ad = PC\n        Day = D1\n\n        // follows:\n        // - everyone follows the influencer\n        // - I follows B (so B is suggested to A)\n        // - B follows C (but suggested relation is only \"users followed by followed users\", i.e., A sees B as suggested, not C)\n        follows = A->I + B->I + C->I + I->B + B->C\n\n        // posts: influencer posts PI (non-ad); B posts PB (non-ad); C posts PC (ad)\n        posts = I->PI + B->PB + C->PC\n\n        // sees: A sees PC (Ad by C) but A neither follows C nor has C in suggested (A.suggested = B) -> violates requirement\n        sees = A->PC\n\n        // suggested: A is suggested B (because A follows I and I follows B). C is not in A.suggested.\n        suggested = A->B\n\n        date = PI->D1 + PB->D1 + PC->D1\n    }\n} for 4 User, 3 Photo, 1 Day expect 0"
            ]
        }
    },
    "Production line": {
        "this/inv1": {
            "parse": [
                "run Pos1 {\n    some disj WS1, WS2 : Workstation | {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n\n        Worker = none\n        Human = none\n        Robot = none\n\n        Product = none\n        Material = none\n        Component = none\n        Dangerous = none\n\n        Workstation.workers = none->none\n        Workstation.succ = none->none\n        Component.workstation = none->none\n        Product.parts = none->none\n    }\n} for 2 Workstation, 0 Worker, 0 Product expect 1",
                "run Pos2 {\n    some disj WS1, WS2 : Workstation | some disj H1 : Worker | {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n\n        Worker = H1\n        Human = H1\n        Robot = none\n\n        Product = none\n        Material = none\n        Component = none\n        Dangerous = none\n\n        Workstation.workers = WS1->H1\n        Workstation.succ = none->none\n        Component.workstation = none->none\n        Product.parts = none->none\n    }\n} for 2 Workstation, 1 Worker, 0 Product expect 1",
                "run Pos3 {\n    some disj WS1, WS2 : Workstation | some disj H1, R1 : Worker | some disj M1, C1 : Product | {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n\n        Worker = H1 + R1\n        Human = H1\n        Robot = R1\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = none\n\n        Workstation.workers = WS1->H1 + WS2->R1\n        Workstation.succ = WS1->WS2\n        Component.workstation = C1->WS2\n        Product.parts = C1->M1\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 1",
                "run Neg1 {\n    some disj WS1, WS2 : Workstation | some disj W1 : Worker | {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n\n        Worker = W1\n        Human = none\n        Robot = none\n\n        Product = none\n        Material = none\n        Component = none\n        Dangerous = none\n\n        Workstation.workers = WS1->W1\n        Workstation.succ = none->none\n        Component.workstation = none->none\n        Product.parts = none->none\n    }\n} for 2 Workstation, 1 Worker, 0 Product expect 0",
                "run Neg2 {\n    some disj WS1, WS2 : Workstation | some disj H1, W2 : Worker | {\n        Workstation = WS1 + WS2\n        begin = WS1\n        end = WS2\n\n        Worker = H1 + W2\n        Human = H1\n        Robot = none\n\n        Product = none\n        Material = none\n        Component = none\n        Dangerous = none\n\n        Workstation.workers = WS1->H1 + WS2->W2\n        Workstation.succ = WS1->WS2\n        Component.workstation = none->none\n        Product.parts = none->none\n    }\n} for 2 Workstation, 2 Worker, 0 Product expect 0",
                "run Neg3 {\n    some disj WS1, WS2, WS3 : Workstation | some disj W1 : Worker | some disj M1, C1 : Product | {\n        Workstation = WS1 + WS2 + WS3\n        begin = WS1\n        end = WS3\n\n        Worker = W1\n        Human = none\n        Robot = none\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = none\n\n        Workstation.workers = WS2->W1\n        Workstation.succ = WS1->WS2 + WS2->WS3\n        Component.workstation = C1->WS2\n        Product.parts = C1->M1\n    }\n} for 3 Workstation, 1 Worker, 2 Product expect 0"
            ]
        },
        "this/inv4": {
            "parse": [
                "run Neg1 {\n    some disj W1, W2 : Workstation |\n    some disj H1 : Human |\n    some disj R1 : Robot |\n    some disj C1 : Component |\n    some disj M1 : Material {\n        Workstation = W1 + W2\n        Worker = H1 + R1\n        Human = H1\n        Robot = R1\n        Product = C1 + M1\n        Component = C1\n        Material = M1\n        Dangerous = none\n        workers = W1->H1 + W2->R1\n        succ = none->none\n        parts = none\n        workstation = C1->W1\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0"
            ]
        },
        "this/inv5": {
            "consistent": [
                "run Neg2 {\n    some disj WS1, WS2 : Workstation |\n    some disj W1, W2, W3 : Worker |\n    some disj H1, H2 : Human |\n    some disj R1 : Robot |\n    some disj P1, P2, P3 : Product |\n    some disj M1, M2 : Material |\n    some disj C1, C2 : Component {\n        Workstation = WS1 + WS2\n        Worker = W1 + W2 + W3\n        Human = H1 + H2\n        Robot = R1\n\n        begin = WS1\n        end = WS2\n\n        workers = WS1->W1 + WS1->W2 + WS2->W3   // assume W1,W2 at WS1 (humans), W3 at WS2 (robot)\n        // Now mix at WS2 by also placing a human at WS2:\n        workers = workers + WS2->W2               // W2 is human and also placed at WS2 => mixing human and robot at WS2\n\n        succ = WS1->WS2\n\n        Product = M1 + M2 + C1\n        Material = M1 + M2\n        Component = C1\n        Dangerous = none\n\n        parts = C1->M1 + C1->M2\n        workstation = C1->WS2\n    }\n} for 2 Workstation, 3 Worker, 3 Product expect 0"
            ]
        },
        "this/inv6": {
            "parse": [
                "run InstanceP1 {\n    // Positive: No component is its own part. Humans and robots are separated by workstation.\n    some disj W1, W2 : Workstation |\n    some disj H1, R1 : Worker |\n    some disj C1, M1 : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n        Worker = H1 + R1\n        Human = H1\n        Robot = R1\n\n        Product = C1 + M1\n        Component = C1\n        Material = M1\n        Dangerous = none\n\n        // each workstation has workers; workers appear in exactly one workstation (by construction)\n        Workstation.workers = W1->H1 + W2->R1\n        // no successor links in this instance\n        Workstation.succ = none->none\n\n        // components must have parts; materials have no parts\n        Product.parts = C1->M1\n\n        // every component assembled in one workstation\n        Component.workstation = C1->W1\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 1",
                "run InstanceP2 {\n    // Positive: Components have parts (no component is its own part). Humans and robots do not mix in any workstation.\n    some disj W1, W2 : Workstation |\n    some disj H1, H2, R1 : Worker |\n    some disj C1, C2, M1 : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n        Worker = H1 + H2 + R1\n        Human = H1 + H2\n        Robot = R1\n\n        Product = C1 + C2 + M1\n        Component = C1 + C2\n        Material = M1\n        Dangerous = none\n\n        // W1 only humans, W2 only robot \u2014 no mixing\n        Workstation.workers = W1->H1 + W1->H2 + W2->R1\n        Workstation.succ = none->none\n\n        // C1's parts is C2; C2's parts is M1. No component is its own part.\n        Product.parts = C1->C2 + C2->M1\n\n        // each component assembled in exactly one workstation\n        Component.workstation = C1->W1 + C2->W2\n    }\n} for 2 Workstation, 3 Worker, 3 Product expect 1",
                "run InstanceP3 {\n    // Positive: Succ relation present; components have parts that are not themselves. Humans and robots separated.\n    some disj W1, W2 : Workstation |\n    some disj R1, R2 : Worker |\n    some disj C1, M1, M2 : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n        Worker = R1 + R2\n        Human = none\n        Robot = R1 + R2\n\n        Product = C1 + M1 + M2\n        Component = C1\n        Material = M1 + M2\n        Dangerous = none\n\n        // both workers are robots but in different workstations; robots and humans do not mix\n        Workstation.workers = W1->R1 + W2->R2\n\n        // a simple ordering of workstations\n        Workstation.succ = W1->W2\n\n        // component has two material parts; materials have no parts\n        Product.parts = C1->M1 + C1->M2\n\n        Component.workstation = C1->W2\n    }\n} for 2 Workstation, 2 Worker, 3 Product expect 1",
                "run InstanceN1 {\n    // Negative: Component C1 is its own part (violates \"Components cannot be their own parts\").\n    some disj W1, W2 : Workstation |\n    some disj H1, R1 : Worker |\n    some disj C1, M1 : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n        Worker = H1 + R1\n        Human = H1\n        Robot = R1\n\n        Product = C1 + M1\n        Component = C1\n        Material = M1\n        Dangerous = none\n\n        Workstation.workers = W1->H1 + W2->R1\n        Workstation.succ = none->none\n\n        // C1 has itself as a part (self-loop) \u2014 this is the violating element\n        Product.parts = C1->C1 + C1->M1\n\n        Component.workstation = C1->W1\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0",
                "run InstanceN2 {\n    // Negative: Component Cx includes itself among its parts, violating the rule. Other requirements still satisfied.\n    some disj W1, W2 : Workstation |\n    some disj H1, H2 : Worker |\n    some disj Cx, My : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n        Worker = H1 + H2\n        Human = H1 + H2\n        Robot = none\n\n        Product = Cx + My\n        Component = Cx\n        Material = My\n        Dangerous = none\n\n        Workstation.workers = W1->H1 + W2->H2\n        Workstation.succ = none->none\n\n        // Component includes itself as a part (self membership)\n        Product.parts = Cx->Cx\n\n        Component.workstation = Cx->W2\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0",
                "run InstanceN3 {\n    // Negative: A component is its own part; succ relation used. All other domain constraints satisfied.\n    some disj W1, W2 : Workstation |\n    some disj R1, R2 : Worker |\n    some disj C1, C2, M1 : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n        Worker = R1 + R2\n        Human = none\n        Robot = R1 + R2\n\n        Product = C1 + C2 + M1\n        Component = C1 + C2\n        Material = M1\n        Dangerous = none\n\n        // robots only, but robots do not share a workstation with humans (none present)\n        Workstation.workers = W1->R1 + W2->R2\n\n        // non-empty successor relation\n        Workstation.succ = W1->W2\n\n        // C1 is its own part (violation); C2 has M1\n        Product.parts = C1->C1 + C2->M1\n\n        Component.workstation = C1->W1 + C2->W2\n    }\n} for 2 Workstation, 2 Worker, 3 Product expect 0"
            ]
        },
        "this/inv8": {
            "parse": [
                "run Pos1 {\n    some disj R1, R2 : Worker {\n        Workstation = begin + end\n        Worker = R1 + R2\n        Human = none\n        Robot = R1 + R2\n        Workstation.workers = begin->R1 + end->R2\n        Workstation.succ = none->none\n\n        Product = none\n        Material = none\n        Component = none\n        Dangerous = none\n        parts = none->none\n        workstation = none->none\n    }\n} for 2 Workstation, 2 Worker, 0 Product expect 1",
                "run Pos2 {\n    some disj R1, H1, C1, M1 : Product + Worker {\n        Workstation = begin + end\n        Worker = R1 + H1\n        Human = H1\n        Robot = R1\n        Workstation.workers = begin->R1 + end->H1\n        Workstation.succ = none->none\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        Dangerous = M1 + C1\n        parts = C1->M1\n        workstation = C1->begin\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 1",
                "run Pos3 {\n    some disj R1, R2, C1, C2, M1 : Worker + Product {\n        Workstation = begin + end\n        Worker = R1 + R2\n        Human = none\n        Robot = R1 + R2\n        Workstation.workers = begin->R1 + end->R2\n        Workstation.succ = begin->end\n\n        Product = C1 + C2 + M1\n        Material = M1\n        Component = C1 + C2\n        Dangerous = M1 + C2 + C1\n        parts = C2->M1 + C1->C2\n        workstation = C1->end + C2->begin\n    }\n} for 2 Workstation, 2 Worker, 3 Product expect 1",
                "run Neg1 {\n    some disj H1, H2, C1, M1 : Worker + Product {\n        Workstation = begin + end\n        Worker = H1 + H2\n        Human = H1 + H2\n        Robot = none\n        Workstation.workers = begin->H1 + end->H2\n        Workstation.succ = none->none\n\n        Product = C1 + M1\n        Material = M1\n        Component = C1\n        Dangerous = M1 + C1\n        parts = C1->M1\n        workstation = C1->begin\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0",
                "run Neg2 {\n    some disj H1, H2, C1, C2 : Worker + Product {\n        Workstation = begin + end\n        Worker = H1 + H2\n        Human = H1 + H2\n        Robot = none\n        Workstation.workers = begin->H1 + end->H2\n        Workstation.succ = none->none\n\n        Product = C1 + C2\n        Material = none\n        Component = C1 + C2\n        Dangerous = C2 + C1\n        parts = C1->C2 + C2->none\n        workstation = C1->end + C2->begin\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0",
                "run Neg3 {\n    some disj H1, H2, Cx, Mx : Worker + Product {\n        Workstation = begin + end\n        Worker = H1 + H2\n        Human = H1 + H2\n        Robot = none\n        Workstation.workers = begin->H1 + end->H2\n        Workstation.succ = begin->end\n\n        Product = Cx + Mx\n        Material = Mx\n        Component = Cx\n        Dangerous = Mx + Cx\n        parts = Cx->Mx\n        workstation = Cx->begin\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 0"
            ]
        },
        "this/inv9": {
            "parse": [
                "run Pos1 {\n    some disj W1, W2 : Workstation |\n    some disj H1, H2 : Worker |\n    some disj M1, C1 : Product {\n        Workstation = W1 + W2\n        begin = W1\n        end = W2\n\n        Worker = H1 + H2\n        Human = H1 + H2\n        Robot = none\n\n        workers = W1->H1 + W2->H2\n        succ = W1->W2\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = none\n\n        Product.parts = C1->M1\n        Component.workstation = C1->W2\n    }\n} for 2 Workstation, 2 Worker, 2 Product expect 1",
                "run Pos2 {\n    some disj W1, W2, W3 : Workstation |\n    some disj H1, H2, R1 : Worker |\n    some disj M1, C1 : Product {\n        Workstation = W1 + W2 + W3\n        begin = W1\n        end = W3\n\n        Worker = H1 + H2 + R1\n        Human = H1 + H2\n        Robot = R1\n\n        workers = W1->H1 + W2->R1 + W3->H2\n        succ = W1->W2 + W2->W3\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = M1 + C1\n\n        Product.parts = C1->M1\n        Component.workstation = C1->W2\n    }\n} for 3 Workstation, 3 Worker, 2 Product expect 1",
                "run Pos3 {\n    some disj W1, W2, W3, W4 : Workstation |\n    some disj H1, H2, H3, R1 : Worker |\n    some disj M1, C2, C1 : Product {\n        Workstation = W1 + W2 + W3 + W4\n        begin = W1\n        end = W4\n\n        Worker = H1 + H2 + H3 + R1\n        Human = H1 + H2 + H3\n        Robot = R1\n\n        workers = W1->H1 + W2->H2 + W3->R1 + W4->H3\n        succ = W1->W2 + W2->W3 + W3->W4\n\n        Product = M1 + C2 + C1\n        Material = M1\n        Component = C2 + C1\n        Dangerous = M1 + C2 + C1\n\n        Product.parts = C2->M1 + C1->C2\n        Component.workstation = C2->W3 + C1->W3\n    }\n} for 4 Workstation, 4 Worker, 3 Product expect 1",
                "run Neg1_Branch {\n    some disj W1, W2, W3 : Workstation |\n    some disj H1, H2, H3 : Worker |\n    some disj M1, C1 : Product {\n        Workstation = W1 + W2 + W3\n        begin = W1\n        end = W3\n\n        Worker = H1 + H2 + H3\n        Human = H1 + H2 + H3\n        Robot = none\n\n        workers = W1->H1 + W2->H2 + W3->H3\n        // Branching: W1 has two successors -> not a single line\n        succ = W1->W2 + W1->W3 + W2->W3\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = none\n\n        Product.parts = C1->M1\n        Component.workstation = C1->W2\n    }\n} for 3 Workstation, 3 Worker, 2 Product expect 0",
                "run Neg2_Disconnected {\n    some disj W1, W2, W3 : Workstation |\n    some disj H1, H2, H3 : Worker |\n    some disj M1, C1 : Product {\n        Workstation = W1 + W2 + W3\n        begin = W1\n        end = W2\n\n        Worker = H1 + H2 + H3\n        Human = H1 + H2 + H3\n        Robot = none\n\n        // W3 is disconnected from the path begin->end\n        workers = W1->H1 + W2->H2 + W3->H3\n        succ = W1->W2\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = none\n\n        Product.parts = C1->M1\n        Component.workstation = C1->W1\n    }\n} for 3 Workstation, 3 Worker, 2 Product expect 0",
                "run Neg3_Cycle {\n    some disj W1, W2, W3 : Workstation |\n    some disj H1, H2, R1 : Worker |\n    some disj M1, C1 : Product {\n        Workstation = W1 + W2 + W3\n        begin = W1\n        end = W3\n\n        Worker = H1 + H2 + R1\n        Human = H1 + H2\n        Robot = R1\n\n        workers = W1->H1 + W2->H2 + W3->R1\n        // Cycle: W1->W2->W3->W1\n        succ = W1->W2 + W2->W3 + W3->W1\n\n        Product = M1 + C1\n        Material = M1\n        Component = C1\n        Dangerous = none\n\n        Product.parts = C1->M1\n        Component.workstation = C1->W2\n    }\n} for 3 Workstation, 3 Worker, 2 Product expect 0"
            ]
        }
    },
    "Train station": {
        "this/inv4": {
            "consistent": [
                "run Neg1 {\n    some disj T1, T2: Track | some disj S1: Signal {\n        // Negative: T1 -> T2 but Entry is (incorrectly) set to T2, which does have a predecessor, so Entry != tracks-without-predecessors.\n        Track = T1 + T2\n        Signal = S1\n        succs = T1->T2\n        signals = T1->S1\n        Entry = T2\n        Exit = T2\n        Junction = none\n        Semaphore = S1\n        Speed = none\n\n        Entry = { t: Track | no t.~succs }\n        Exit = { t: Track | no t.succs }\n        some Entry\n        some Exit\n        all s: Signal | one t: Track | s in t.signals\n    }\n} for 2 Track, 1 Signal expect 0",
                "run Neg2 {\n    some disj T1, T2: Track | some disj S1: Signal {\n        // Negative: both tracks have no predecessors, so RHS = T1 + T2, but Entry is (incorrectly) only T1 (missing T2), violating the requirement.\n        Track = T1 + T2\n        Signal = S1\n        succs = none->none\n        signals = T1->S1\n        Entry = T1\n        Exit = T1 + T2\n        Junction = none\n        Semaphore = none\n        Speed = none\n\n        Entry = { t: Track | no t.~succs }\n        Exit = { t: Track | no t.succs }\n        some Entry\n        some Exit\n        all s: Signal | one t: Track | s in t.signals\n    }\n} for 2 Track, 1 Signal expect 0",
                "run Neg3 {\n    some disj T1, T2, T3: Track | some disj S1: Signal {\n        // Negative: chain T1->T2->T3, only T1 has no predecessors, but Entry is (incorrectly) set to T2+T3, so it does not equal tracks-without-predecessors.\n        Track = T1 + T2 + T3\n        Signal = S1\n        succs = T1->T2 + T2->T3\n        signals = T2->S1\n        Entry = T2 + T3\n        Exit = T3\n        Junction = none\n        Semaphore = S1\n        Speed = none\n\n        Entry = { t: Track | no t.~succs }\n        Exit = { t: Track | no t.succs }\n        some Entry\n        some Exit\n        all s: Signal | one t: Track | s in t.signals\n    }\n} for 3 Track, 1 Signal expect 0"
            ]
        },
        "this/inv7": {
            "previous": [
                "run InstanceNeg3 {\n    some disj E, A, B, C, D : Track | some disj Se, Sa, Sd : Signal {\n        Track = E + A + B + C + D\n        Signal = Se + Sa + Sd\n        succs = E->A + A->B + B->C + C->A\n        signals = E->Se + B->Sa + D->Sd\n        Entry = E\n        Exit = D\n        Junction = A\n        Speed = Se\n        Semaphore = Sa + Sd\n    }\n} for 5 Track, 3 Signal expect 0"
            ]
        },
        "this/inv9": {
            "previous": [
                "run Pos2 {\n    some disj E, X : Track | some disj S1, S2 : Signal {\n        Track = E + X\n        Signal = S1 + S2\n        succs = E->X\n        signals = E->S1  // X has no signals\n        Entry = E\n        Exit = X\n        Junction = none\n        Speed = S1\n        Semaphore = none\n    }\n} for 2 Track, 2 Signal expect 1"
            ]
        }
    },
    "Courses": {
        "this/inv2": {
            "parse": [
                "run Positive1 {\n    // Positive: The only person (P1) is a Professor and is the only one who teaches; no non-professor teaches. No one is enrolled (vacuously only students are enrolled).\n    some disj P1 : Person | some disj C1 : Course | some disj G1, G2 : Grade {\n        Person = P1\n        Professor = P1\n        Student = none\n        Course = C1\n        Project = none\n\n        teaches = P1->C1\n        enrolled = none\n\n        Person <: projects = none->none\n        Course <: projects = none->none\n\n        Course <: grades = none->none->none\n\n        Grade = G1 + G2\n        Grade <: next = G1->G2\n    }\n} for 1 Person, 1 Course, 0 Project, 2 Grade expect 1",
                "run Negative2 {\n    // Negative: P1 is neither Professor nor Student but P1 teaches C1, violating \"Only professors can teach courses\". No one is enrolled, so the enrollment requirement holds.\n    some disj P1 : Person | some disj C1 : Course | some disj G1, G2 : Grade {\n        Person = P1\n        Professor = none\n        Student = none\n        Course = C1\n        Project = none\n\n        teaches = P1->C1\n        enrolled = none\n\n        Person <: projects = none->none\n        Course <: projects = none->none\n\n        Course <: grades = none->none->none\n\n        Grade = G1 + G2\n        Grade <: next = G1->G2\n    }\n} for 1 Person, 1 Course, 0 Project, 2 Grade expect 0"
            ]
        },
        "this/inv5": {
            "parse": [
                "run Pos1 {\n\t// Positive: only students work on projects (Stud1 works on P1) and every project has someone; other requirements satisfied.\n\tsome disj Prof1, Stud1 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n\t\tPerson = Prof1 + Stud1\n\t\tProfessor = Prof1\n\t\tStudent = Stud1\n\t\tCourse = C1\n\t\tProject = P1\n\t\tGrade = G1 + G2\n\n\t\tPerson.teaches = Prof1->C1\n\t\tPerson.enrolled = Stud1->C1\n\t\tPerson.projects = Stud1->P1\n\n\t\tC1.projects = C1->P1\n\t\tC1.grades = C1->Stud1->G1\n\n\t\tGrade <: next = G1->G2\n\t}\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 1",
                "run Pos2 {\n\t// Positive: only students (Stud1, Stud2) work on the single project P1 (both work on it); every project has someone; other requirements satisfied.\n\tsome disj Prof1, Stud1, Stud2 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n\t\tPerson = Prof1 + Stud1 + Stud2\n\t\tProfessor = Prof1\n\t\tStudent = Stud1 + Stud2\n\t\tCourse = C1\n\t\tProject = P1\n\t\tGrade = G1 + G2\n\n\t\tPerson.teaches = Prof1->C1\n\t\tPerson.enrolled = Stud1->C1 + Stud2->C1\n\t\tPerson.projects = Stud1->P1 + Stud2->P1\n\n\t\tC1.projects = C1->P1\n\t\tC1.grades = C1->Stud1->G1 + C1->Stud2->G2\n\n\t\tGrade <: next = G1->G2\n\t}\n} for 3 Person, 1 Course, 1 Project, 2 Grade expect 1",
                "run Pos3 {\n\t// Positive: two courses C1,C2 each propose one project P1,P2; only students (Stud1,Stud2) work on their respective projects; other requirements satisfied.\n\tsome disj Prof1, Prof2, Stud1, Stud2 : Person | some disj C1, C2 : Course | some disj P1, P2 : Project | some disj G1, G2 : Grade {\n\t\tPerson = Prof1 + Prof2 + Stud1 + Stud2\n\t\tProfessor = Prof1 + Prof2\n\t\tStudent = Stud1 + Stud2\n\t\tCourse = C1 + C2\n\t\tProject = P1 + P2\n\t\tGrade = G1 + G2\n\n\t\tPerson.teaches = Prof1->C1 + Prof2->C2\n\t\tPerson.enrolled = Stud1->C1 + Stud2->C2\n\t\tPerson.projects = Stud1->P1 + Stud2->P2\n\n\t\tC1.projects = C1->P1\n\t\tC2.projects = C2->P2\n\t\tC1.grades = C1->Stud1->G1\n\t\tC2.grades = C2->Stud2->G2\n\n\t\tGrade <: next = G1->G2\n\t}\n} for 4 Person, 2 Course, 2 Project, 2 Grade expect 1",
                "run Neg1 {\n\t// Negative: a professor (Prof1) works on P1, violating \"only students work on projects\"; other requirements satisfied.\n\tsome disj Prof1, Stud1 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n\t\tPerson = Prof1 + Stud1\n\t\tProfessor = Prof1\n\t\tStudent = Stud1\n\t\tCourse = C1\n\t\tProject = P1\n\t\tGrade = G1 + G2\n\n\t\tPerson.teaches = Prof1->C1\n\t\tPerson.enrolled = Stud1->C1\n\t\tPerson.projects = Prof1->P1            // professor works on a project -> violates \"only students work on projects\"\n\n\t\tC1.projects = C1->P1\n\t\tC1.grades = C1->Stud1->G1\n\n\t\tGrade <: next = G1->G2\n\t}\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 0",
                "run Neg2 {\n\t// Negative: project P1 is proposed by C1 but no one works on it, violating \"projects must have someone working on them\"; other requirements satisfied.\n\tsome disj Prof1, Stud1 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n\t\tPerson = Prof1 + Stud1\n\t\tProfessor = Prof1\n\t\tStudent = Stud1\n\t\tCourse = C1\n\t\tProject = P1\n\t\tGrade = G1 + G2\n\n\t\tPerson.teaches = Prof1->C1\n\t\tPerson.enrolled = Stud1->C1\n\t\tPerson.projects = none->none           // no one works on any project -> P1 has no workers\n\n\t\tC1.projects = C1->P1\n\t\tC1.grades = C1->Stud1->G1\n\n\t\tGrade <: next = G1->G2\n\t}\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 0",
                "run Neg3 {\n\t// Negative: project P2 (proposed by C2) has no one working on it, while P1 has a student; thus some project lacks workers -> violation; other requirements satisfied.\n\tsome disj Prof1, Prof2, Stud1 : Person | some disj C1, C2 : Course | some disj P1, P2 : Project | some disj G1, G2 : Grade {\n\t\tPerson = Prof1 + Prof2 + Stud1\n\t\tProfessor = Prof1 + Prof2\n\t\tStudent = Stud1\n\t\tCourse = C1 + C2\n\t\tProject = P1 + P2\n\t\tGrade = G1 + G2\n\n\t\tPerson.teaches = Prof1->C1 + Prof2->C2\n\t\tPerson.enrolled = Stud1->C1\n\t\tPerson.projects = Stud1->P1            // P1 has a student working, P2 has none -> P2 violates \"projects must have someone working on them\"\n\n\t\tC1.projects = C1->P1\n\t\tC2.projects = C2->P2\n\t\tC1.grades = C1->Stud1->G1\n\t\tC2.grades = none->none->none          // no grades for C2\n\n\t\tGrade <: next = G1->G2\n\t}\n} for 3 Person, 2 Course, 2 Project, 2 Grade expect 0"
            ]
        },
        "this/inv6": {
            "parse": [
                "run Neg2 {\n    some disj ProfE, StudE : Person |\n    some disj C7 : Course |\n    some disj P7 : Project |\n    some disj G9, G10 : Grade {\n        Person = ProfE + StudE\n        Professor = ProfE\n        Student = StudE\n        Course = C7\n        Project = P7\n        Grade = G9 + G10\n\n        teaches = ProfE->C7\n        enrolled = none                       // StudE enrolled in no course\n\n        Person <: projects = StudE->P7        // StudE works on P7\n        Course <: projects = C7->P7           // P7 is proposed by C7, StudE not enrolled in C7\n\n        grades = none->none->none\n\n        Grade <: next = G9->G10\n    }\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 0"
            ]
        },
        "this/inv8": {
            "previous": [
                "run Neg3 {\n    some disj PS, S2 : Person | some disj C1, C2 : Course | some disj PJ1, PJ2 : Project | some disj G1, G2 : Grade {\n        Person = PS + S2\n        Professor = PS\n        Student = PS + S2\n        Course = C1 + C2\n        Project = PJ1 + PJ2\n        Grade = G1 + G2\n\n        Person <: teaches = PS->C1\n        Person <: enrolled = PS->C1 + PS->C2 + S2->C2\n        Person <: projects = PS->PJ1 + S2->PJ2\n        Course <: projects = C1->PJ1 + C2->PJ2\n        Course <: grades = C1->PS->G1 + C2->S2->G2\n\n        Grade <: next = G1->G2\n    }\n} for 2 Person, 2 Course, 2 Project, 2 Grade expect 0"
            ]
        },
        "this/inv9": {
            "valid": [
                "run Instance4 {\n\t// Negative: course C1 is co-taught by two distinct professors P1 and P2 (violates \"A professor cannot teach colleagues\"). Other requirements satisfied: only students enrolled, projects proposed by C1 and worked on by enrolled students.\n\tsome disj P1, P2, S1 : Person | some disj C1 : Course | some disj Pr1 : Project | some disj G1 : Grade {\n\t\tPerson = P1 + P2 + S1\n\t\tProfessor = P1 + P2\n\t\tStudent = S1\n\t\tCourse = C1\n\t\tProject = Pr1\n\t\tGrade = G1\n\n\t\tteaches = P1->C1 + P2->C1\n\t\tenrolled = S1->C1\n\n\t\tPerson <: projects = S1->Pr1\n\t\tCourse <: projects = C1->Pr1\n\n\t\tgrades = C1->S1->G1\n\t}\n} for 3 Person, 1 Course, 1 Project, 1 Grade expect 0",
                "run Instance5 {\n\t// Negative: course Cshared is taught by two professors P1 and P2 (co-teaching). Two students S1,S2 are enrolled and work on distinct projects of that course. All other constraints hold.\n\tsome disj P1, P2, S1, S2 : Person | some disj Cshared : Course | some disj Pr1, Pr2 : Project | some disj G1, G2 : Grade {\n\t\tPerson = P1 + P2 + S1 + S2\n\t\tProfessor = P1 + P2\n\t\tStudent = S1 + S2\n\t\tCourse = Cshared\n\t\tProject = Pr1 + Pr2\n\t\tGrade = G1 + G2\n\n\t\tteaches = P1->Cshared + P2->Cshared\n\t\tenrolled = S1->Cshared + S2->Cshared\n\n\t\tPerson <: projects = S1->Pr1 + S2->Pr2\n\t\tCourse <: projects = Cshared->Pr1 + Cshared->Pr2\n\n\t\tgrades = Cshared->S1->G1 + Cshared->S2->G2\n\t}\n} for 4 Person, 1 Course, 2 Project, 2 Grade expect 0",
                "run Instance6 {\n\t// Negative: course C1 is co-taught by professors P1 and P2 (violates no-colleagues-teaching). Projects and enrollments are set so all project-related constraints hold; professors are not enrolled (so \"cannot teach herself\" trivially holds).\n\tsome disj P1, P2, S1 : Person | some disj C1, C2 : Course | some disj Pr1 : Project | some disj G1 : Grade {\n\t\tPerson = P1 + P2 + S1\n\t\tProfessor = P1 + P2\n\t\tStudent = S1\n\t\tCourse = C1 + C2\n\t\tProject = Pr1\n\t\tGrade = G1\n\n\t\tteaches = P1->C1 + P2->C1 + P1->C2\n\t\tenrolled = S1->C1\n\n\t\tPerson <: projects = S1->Pr1\n\t\tCourse <: projects = C1->Pr1\n\n\t\tgrades = C1->S1->G1\n\t}\n} for 3 Person, 2 Course, 1 Project, 1 Grade expect 0"
            ]
        },
        "this/inv10": {
            "parse": [
                "run Pos1 {\n    // Positive: only students have grades; professor teaches the course; student enrolled, works on the course project; all other requirements satisfied.\n    some disj Prof1, Stu1 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n        Person = Prof1 + Stu1\n        Professor = Prof1\n        Student = Stu1\n        Course = C1\n        Project = P1\n        Grade = G1 + G2\n\n        // relations\n        teaches = Prof1->C1\n        enrolled = Stu1->C1\n        projects = Stu1->P1\n        C1.projects = C1->P1\n        C1.grades = Stu1->G1\n\n        // ordering for Grade (total order next)\n        Grade <: next = G1->G2\n    }\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 1",
                "run Pos2 {\n    // Positive: two students each have a grade in their course; single professor teaches both courses; students only work on projects of courses they're enrolled in; all constraints satisfied.\n    some disj Prof1, Stu1, Stu2 : Person | some disj C1, C2 : Course | some disj P1, P2 : Project | some disj G1, G2 : Grade {\n        Person = Prof1 + Stu1 + Stu2\n        Professor = Prof1\n        Student = Stu1 + Stu2\n        Course = C1 + C2\n        Project = P1 + P2\n        Grade = G1 + G2\n\n        teaches = Prof1->C1 + Prof1->C2\n        enrolled = Stu1->C1 + Stu2->C2\n        projects = Stu1->P1 + Stu2->P2\n        C1.projects = C1->P1\n        C2.projects = C2->P2\n        C1.grades = Stu1->G1\n        C2.grades = Stu2->G2\n\n        Grade <: next = G1->G2\n    }\n} for 3 Person, 2 Course, 2 Project, 2 Grade expect 1",
                "run Pos3 {\n    // Positive: one professor, one student, one course with two projects; student works on at most one project per course (works on one); only students have grades; projects proposed by the course and have someone working on them.\n    some disj Prof1, Stu1 : Person | some disj C1 : Course | some disj P1, P2 : Project | some disj G1, G2 : Grade {\n        Person = Prof1 + Stu1\n        Professor = Prof1\n        Student = Stu1\n        Course = C1\n        Project = P1 + P2\n        Grade = G1 + G2\n\n        teaches = Prof1->C1\n        enrolled = Stu1->C1\n        projects = Stu1->P1    // student works only on P1 (at most one project for C1)\n        C1.projects = C1->P1 + C1->P2\n        C1.grades = Stu1->G1   // only student has a grade\n        // ensure P2 also has someone working on it: add a second (also student) worker would violate \"at most one per course\" if same student, so create another student? Instead assign P2 to be worked by Stu1? That would violate constraint. To keep constraints satisfied, ensure P2 also has someone working on it by another student: add Stu2 as a student who is also enrolled.\n    }\n} for 2 Person, 1 Course, 2 Project, 2 Grade expect 1",
                "run Neg1 {\n    // Negative: a professor (Prof1) has a grade -> violates \"Only students have grades\". All other requirements satisfied (professor teaches, students enrolled and work on projects, projects proposed by course, etc.).\n    some disj Prof1, Stu1 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n        Person = Prof1 + Stu1\n        Professor = Prof1\n        Student = Stu1\n        Course = C1\n        Project = P1\n        Grade = G1 + G2\n\n        teaches = Prof1->C1\n        enrolled = Stu1->C1\n        projects = Stu1->P1\n        C1.projects = C1->P1\n        C1.grades = Prof1->G1 + Stu1->G2   // Prof1 has a grade -> violates \"Only students have grades\"\n\n        Grade <: next = G1->G2\n    }\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 0",
                "run Neg2 {\n    // Negative: a professor (Prof1) has a grade in a course she teaches -> violates \"Only students have grades\". Other requirements satisfied: students enrolled and work on projects; each project belongs to one course and has someone working on it.\n    some disj Prof1, Stu1, Stu2 : Person | some disj C1, C2 : Course | some disj P1, P2 : Project | some disj G1, G2, G3 : Grade {\n        Person = Prof1 + Stu1 + Stu2\n        Professor = Prof1\n        Student = Stu1 + Stu2\n        Course = C1 + C2\n        Project = P1 + P2\n        Grade = G1 + G2 + G3\n\n        teaches = Prof1->C1 + Prof1->C2\n        enrolled = Stu1->C1 + Stu2->C2\n        projects = Stu1->P1 + Stu2->P2\n        C1.projects = C1->P1\n        C2.projects = C2->P2\n        C1.grades = Prof1->G1 + Stu1->G2   // Prof1 has a grade -> violates requirement\n\n        Grade <: next = G1->G2 + G2->G3\n    }\n} for 3 Person, 2 Course, 2 Project, 3 Grade expect 0",
                "run Neg3 {\n    // Negative: a professor (Prof1) has a grade while all other constraints hold (professor teaches, no professor enrolled, projects proposed by courses and worked by students, students only work on projects of courses they're enrolled in).\n    some disj Prof1, Stu1 : Person | some disj C1 : Course | some disj P1 : Project | some disj G1, G2 : Grade {\n        Person = Prof1 + Stu1\n        Professor = Prof1\n        Student = Stu1\n        Course = C1\n        Project = P1\n        Grade = G1 + G2\n\n        teaches = Prof1->C1\n        enrolled = Stu1->C1\n        projects = Stu1->P1\n        C1.projects = C1->P1\n        C1.grades = Prof1->G1                     // Professor has a grade -> violates \"Only students have grades\"\n        // No grades for students in this instance, still violates the requirement because a non-student has a grade.\n\n        Grade <: next = G1->G2\n    }\n} for 2 Person, 1 Course, 1 Project, 2 Grade expect 0"
            ]
        }
    }
}